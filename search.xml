<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Network</title>
      <link href="/2023/02/19/Network/"/>
      <url>/2023/02/19/Network/</url>
      
        <content type="html"><![CDATA[<p>1.无状态路由<br>2.分布式系统是一个模型，在操作系统之上有一层中间件负责实现这个模型，<br>万维网是一个典型的分布式系统，运行在internet之上，模型中的一切都表现<br>的像是一个文档(Web页面)一样</p><ol><li>PDU协议数据单元：data/segment/packet/frame/bit（越底层的越靠外-&gt;”层层封装”）<br>4.无连接服务、面向连接服务；<br>5.协议：语法语义同步<br>6.协议与服务的关系：水平、垂直；协议支持服务；<br>7.通信模型：C/S （C/S、B/S、email）|| P2P<br>8.域名（点分字符标识一台或一组计算机的电子方位，是IP的一个代称，即”称呼”；）<br>IP和域名是一对多的关系；一个IP可以有多个域名，每个域名只能代表一个IP；</li></ol><p>9.DNS域名系统和ARP地址解析协议；<br>DNS实现主机名(给人看eg,www.baidu.com)-&gt;IP地址(给路由器看)<br>ARP实现IP-&gt;MAC<br>MAC扁平结构（社会保险号）、IP层次结构（邮编）<br>注：ARP分组封装在链路层帧中，从体系结构上来说位于链路层之上，但又具有链路层地址<br>字段；同时也具有网络层地址字段，所以最准确的理解是，ARP是一个跨边界的协议，不完全<br>符合简单的分层协议栈<br>10.寻址方案：主机名（应用层）、IP地址（网络层）、MAC地址（链路层）；<br>不同层需要有自己的寻址方案，以保证各层成为相对独立的构建模块；<br>注：实际上，不是主机或路由器有链路层地址，而是他们的适配器，即网络接口具有链路层地址<br>11.链路层转发寻址和ARP应用实例（P308）</p><p>12.以太网：最成熟应用最广的有线局域网技术；互联方式：同轴电缆-》集线器-》交换机；<br>向网络层提供无连接服务；不可靠服务，简单和便宜；间隙是否可见取决于上层(TCP/UDP)<br>802.3：1983年IEEE为推进网络设备协议标准化，制定了此标准化以太网协议802.3Standard，<br>简称802.3。<br>13.多路访问协议：信道划分、aloha、CSMA/CD、令牌桶<br>14.交换机：过滤和转发、自学习、即插即用、存储转发；”滤波转发查找”；<br>15.VLAN</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning &amp; Deep Learning</title>
      <link href="/2023/02/19/Machine%20Learning%20&amp;%20Deep%20Learning/"/>
      <url>/2023/02/19/Machine%20Learning%20&amp;%20Deep%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="chapter-1-基础知识"><a href="#chapter-1-基础知识" class="headerlink" title="chapter 1. 基础知识"></a>chapter 1. 基础知识</h2><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p><strong>Machine Learning ≈ Looking for a Correct Function</strong><br>eg.语音识别：f(语音信号) = “How are you”<br>&emsp;&ensp;图像识别：f(图片) = “cat”<br>&emsp;&ensp;alpha Go：f(棋盘) = “下一步落子位置”<br><strong>f的正常编写会很困难，而机器学习就是帮我们找出：人写不出来的那个”复杂函数f”</strong></p><h3 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h3><p>要找的那个函数f是一个 <strong>“类神经网络”</strong></p><h3 id="机器学习的输入与输出"><a href="#机器学习的输入与输出" class="headerlink" title="机器学习的输入与输出"></a>机器学习的输入与输出</h3><p><strong>机器学习可以分为两大类任务，一类叫做regression，另一类叫做classificaton</strong><br>输入可以是一个vector、一个matrix（图片识别）或是一个sequence（语音辨识、翻译）<br>输出可以是一个数值scalar、一组类别或是更复杂的输出，如一篇文章等<br>输出是数值scalar的称为regression，即回归；例如数值预测；<br>输出是类别的，即为机器提供几个选项让他选择，称为分类classification；例如垃圾邮件识别，alpha-Go(所有落点选一个);</p><h3 id="机器如何自动的找出这个函数F"><a href="#机器如何自动的找出这个函数F" class="headerlink" title="机器如何自动的找出这个函数F"></a>机器如何自动的找出这个函数F</h3><p>Supervised Learning监督学习：在Training Data中设置label;缺点是要收集大量数据和设置标签，在实际中难以做到；<br>Self-supervised Learning自监督学习：在训练之前“先练成一些基本功”，即Pre-train预训练 + Downstream Tasks下游任务；<br>Pre-train和Downstream Tasks的关系就好像开发OS和开发APP的关系;<br>Pre-tarined Model也叫Foundation Model，其中最有名的就是BERT模型，有340个参数parameters（《芝麻街》中的小黄人）；此外还有：GPT-3、GPT-2、T5、ELMo；</p><h3 id="补充介绍"><a href="#补充介绍" class="headerlink" title="补充介绍"></a>补充介绍</h3><p><strong>generative adversarial network</strong>：将unpaired的数据输入让机器自己学习得出结果的一种技术；目前做的最好的是facebook的一篇论文：</p><blockquote><p><a href="https://arxiv.org/abs/2105.11084">https://arxiv.org/abs/2105.11084</a></p></blockquote><p><strong>reinforcement learning</strong>：强化学习，适用于难以打标签的场合；例如围棋，人很难知道下一步应该落在哪里是最好的，但我们可以告诉机器什么是好的结果，什么是不好的结果；<br><strong>anomaly detection</strong>：异常检测，让机器拥有回答”我不知道”的能力；<br><strong>explainable AI</strong>：可解释性AI，让机器不仅能输出结果，还要告诉我们为什么，以具有更好的可解释性；<br><strong>model attack</strong>:人类对训练模型的攻击；如插入杂讯；<br><strong>domain adaptation</strong>：域适应；针对实际接受的场景可能与训练场景有区别的情况；比如训练用的是黑白图片，实际变成彩色图片；<br><strong>network compression</strong>：模型压缩，从而让他们跑在更简单的设备上；例如手机、手表；<br><strong>life-long learning</strong>：让机器不断学习新技术会有什么困难？<br><strong>meta learning</strong>：meta learning = learn to learn，即让机器学会学习；meta learning往往用于实现<strong>Few-shot learning</strong>，即采用非常少量的资料让机器学会目标；</p><h3 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h3><p>python、google colab<br>colab全称为Colaboratory,是免费的Jupyter运行环境,并且完全在云端运行。最重要的是免费，而且不需要你自己去装深度学习的环境</p><h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><p><a href="https://www.kaggle.com">https://www.kaggle.com</a><br>一个机器学习的线上平台，包含了很多竞赛内容，部分竞赛甚至设有奖金；<br>项目做完后可以上传到kaggle上跑分，并获知排行；<br>public leaderboard在上传后就可以看到；包含一部分测试集；<br>private leaderboard要在deadline后；包含另一部分；</p><hr><h2 id="chapter-2-Regression"><a href="#chapter-2-Regression" class="headerlink" title="chapter 2. Regression"></a>chapter 2. Regression</h2><h3 id="什么是regression"><a href="#什么是regression" class="headerlink" title="什么是regression"></a>什么是regression</h3><p>the function outputs a scalar<br>例如，输入今天的气象参数到函数f，得出未来的pm2.5的值；</p><h3 id="Structured-Learning"><a href="#Structured-Learning" class="headerlink" title="Structured Learning"></a>Structured Learning</h3><p>即create something with structure(image、document)；用拟人化的方式来说，就是不只是让机器得出结果，还要让机器会创造。</p><h3 id="机器如何找出函数F（即训练过程）"><a href="#机器如何找出函数F（即训练过程）" class="headerlink" title="机器如何找出函数F（即训练过程）"></a>机器如何找出函数F（即训练过程）</h3><blockquote><p>“三步走”：</p><ol><li>写出一个带有未知参数的函数，即猜测一下我们需要预测的目标的数学关系式是什么样的。（eg.猜测明日油管播放量 y = b + wx，x是今日播放量，b 和 w 是未知数，w 可以表示权重 weight，b 可以表示 bias）这个带有未知参数的函数也称为<strong>模型</strong>。</li><li>定义Loss：Loss也是一个Function，此function的输入是model的参数（eg.对于上面的举例，Loss可以表示为L(b,w)）。Loss这个Function输出的值的意义是衡量当前参数的取值好还是不好。一般的，Loss越小，说明取的参数越好。<br><strong>Loss的计算方式</strong>：MAE(mean absolute error)、MSE(mean square error)等；<br>注意：Loss是可以根据实际场景去自己定义的。</li><li>Optimization最佳化；即找出最好的 $w^{<em>}$ 和 $b^{</em>}$，使得Loss取最小值。<br>一个最常用的optimize的方法就是Gradient Descent，即<strong>梯度下降法</strong>。<br><strong>梯度下降法的步骤</strong>：<br>I. 先随机取一个点$w_0$；<br>II. 然后计算 $\frac{\partial L}{\partial w}|_{w=w_0}$ ，如果为负，则增加w；如果为正，则减小w；<br>每次移动的值表示为 $\eta\frac{\partial L}{\partial w}|_{w=w_0}$ ；即偏微分越大，移动越多；$\eta$ 称为<strong>learning rate</strong>，即学习率，$\eta$ 越大每次跳的越多，反之越小。它的值是由我们自己去定义的。像 $\eta$ 这样由我们设定而非机器去学习得来的参数称为 <strong>hyperparameter</strong>；<br>III. 接下来更新 w，即 $w_1=w_0-\eta\frac{\partial L}{\partial w}|_{w=w_0}$<br><strong>思考：为什么是减？</strong> 原因是我们希望找最小的L，当偏导为负时要增加，偏导为正时要减小；联系梯度下降的概念，实际上梯度是当前函数增加最快的方向，则 <strong>负梯度方向是函数减少最快的方向。</strong><br>IV. 持续移动 w 直到结束；<strong>结束条件</strong>可以是更新次数上限(hyperparameter)、微分值为零的点(<strong>局部最优解local minima</strong>)；</li></ol></blockquote><h3 id="关于方向导数和梯度的数学补充"><a href="#关于方向导数和梯度的数学补充" class="headerlink" title="关于方向导数和梯度的数学补充"></a>关于方向导数和梯度的数学补充</h3><p>关于方向导数：<br><img src="/medias/blog/方向导数.png" alt="方向导数" title="方向导数"><br>关于梯度：<br><img src="/medias/blog/梯度.png" alt="梯度" title="梯度"><br>多参数问题用Gradient Decent:<br><img src="/medias/blog/gradient_decent.png" alt="Gradient Decent" title="Gradient Decent"><br>实例：<br><img src="/medias/blog/梯度下降实例.png" alt="实例" title="Gradient 梯度下降"></p><h3 id="模型修改"><a href="#模型修改" class="headerlink" title="模型修改"></a>模型修改</h3><p><strong>对模型的修改往往源于对于问题实际情况的深入理解，即Domain Knowledge</strong><br>一般来讲，在训练数据上考虑因素越多，在训练集上的Loss越小。例如，预测播放量中考虑前一天和考虑前七天的差异。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Automata</title>
      <link href="/2023/02/19/Automata/"/>
      <url>/2023/02/19/Automata/</url>
      
        <content type="html"><![CDATA[<h2 id="自动机Automata"><a href="#自动机Automata" class="headerlink" title="自动机Automata"></a>自动机Automata</h2><ol><li>自动机是一类计算模型。它包含一系列状态，这些状态中：有一种特殊的状态，被称作「初始状态」。还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</li><li>起初，自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则判定该字符串「被拒绝」。注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。</li><li>自动机驱动的编程，可以被看做一种暴力枚举法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联（AC自动机）；在工程领域，它是实现「正则表达式」的基础。</li></ol><h2 id="有限状态自动机FSA"><a href="#有限状态自动机FSA" class="headerlink" title="有限状态自动机FSA"></a>有限状态自动机FSA</h2><p>以 leetcode 剑指offer.20 表示数值的字符串这道题为例，题目要求我们判断给定的字符串是否能表示一个数值。这个场景可以用有限状态自动机FSA来解决。具体步骤如下：</p><blockquote><ol><li>如何描述：用“数值字符串的不同组成部分”作为状态的描述；当前字符所属部分即为当前字符的状态；例如同样是1, 可能是小数部分也可能是整数部分，对应的状态转移情况就不同；</li><li>定义状态：根据题意，可以确定10种状态：0起始空格；1起始符号位；2小数点前整数；3左侧有整数的小数点；4左侧无整数的小数点；5小数部分的值；6指数符号e/E；7幂部分符号；8幂部分整数；9末尾空格；（即10个组成部分）</li><li>确定始末：初始状态 : 0,1,2,4；合法结束状态 : 2,3,5,8,9</li><li>转移规则：根据描述状态的原则，可得转移规则如图所示；</li><li>状态转移图：用hash存储，对输入的key，可以从key转移至value；</li></ol></blockquote><p><img src="/medias/blog/有限状态自动机FSA.png" alt="状态转移图" title="状态转移图"></p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC自动机是一个常用的多模字符串匹配算法；它以<strong>字典树Trie</strong>为实现基础，采用了KMP算法的前缀后缀思想；即，可以认为AC自动机就是一个加料版的Trie。</p><h3 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a>字典树Trie</h3><ol><li>Trie树，即字典树，又称单词查找树或键树，是一种树形结构。一般用于统计和排序超大量字符串（但不仅限于字符串），常被搜索引擎系统用于文本词频统计。</li><li>核心思想是空间换时间：利用字符串的公共前缀来降低查找时间，最大限度地减少无意义的字符串比较；从而提高查找效率；</li><li>Trie结构：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">typedef struct trie <span class="token punctuation">&#123;</span>    struct trie* node<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> //小写字母；也可以52、62<span class="token punctuation">(</span>加0~9<span class="token punctuation">)</span>等    int <span class="token function">v</span><span class="token punctuation">;</span> //记录到本节点为止的相同前缀数目；也可记录单词结束等    //其他记录参数，针对具体适用场景灵活配置<span class="token punctuation">&#125;</span> Trie<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>trie树根节点不含字符，除root外每个节点都只包含一个字符；从root到某节点，路径上经过的字符连起来即为对应字符串；每个节点的所有子节点包含字符均不相同（eg.26、52、62…）;每层的节点数是26^i级别的，为节省空间，可用动态链表或数组来模拟动态；空间的花费，不会超过单词数×单词长度。</li></ol><h3 id="AC自动机的实现"><a href="#AC自动机的实现" class="headerlink" title="AC自动机的实现"></a>AC自动机的实现</h3><ol><li>AC自动机用于对某一特定主串与多个模式串做匹配的情况；它的精妙之处正在于，通过使用fail指针(类似KMP的next[])，结合字典树的性质，减少匹配的回溯次数；</li><li>fail指针的实现是基于前缀后缀思想；对于KMP而言，是在一个串中做前后缀；对于AC自动机而言，是在一棵Trie树上做前后缀；也就是说fail指针会在各个树分支上跳来跳去；可以认为：KMP算法是运行在一条链上的AC自动机；</li><li>AC自动机的前后缀可以是”某条分支自己”；而KMP要求前后缀非平凡；</li><li>fail指针：指向满足”其他分支中前缀部分与自己后缀相同”条件的”最深”的节点；即，fail目的地应该是一个”极大前缀”；由trie的性质，前缀即为某模式串的开头几位；</li><li>root不表示任何值，root的直接孩子的fail一定指向root；</li><li>fail构建：<br><img src="/medias/blog/AC-fail构建.png" alt="fail构建" title="fail构建"></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FSA </tag>
            
            <tag> Trie </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Missing Semester</title>
      <link href="/2023/02/19/Missing%20Semester/"/>
      <url>/2023/02/19/Missing%20Semester/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>&emsp;在麻省理工，有一门课程叫做missing semester，讲授如何高效的使用计算机工具。我想引用课程介绍中的一段话：“计算机是为自动化手工任务而生的，然而学生们却经常用手来完成重复性的任务。计算机生态系统知识，没有作为作为大学课程的一部分来教授。学生们从来没有被告知如何使用这些工具，或者至少没有被告知如何有效的使用这些工具，从而将精力和时间浪费在了本应简单的任务上”。趁着这段时间可以自由安排，我实践和学习了很多基础性的知识，算是补上自己缺失的一课。我将所学记录下来，于是便有了这篇博客。</p><h2 id="chapter-1-compiler"><a href="#chapter-1-compiler" class="headerlink" title="chapter 1 - compiler"></a>chapter 1 - compiler</h2><h3 id="GNU、gcc和MinGW"><a href="#GNU、gcc和MinGW" class="headerlink" title="GNU、gcc和MinGW"></a>GNU、gcc和MinGW</h3><p>首先了解GPL和GNU Project：<br><strong>GNU Project</strong>：革奴计划，是一个自由软件集体协作计划，1983年9月27日由理查德·斯托曼在麻省理工学院公开发起。它的目的是创建一套完全自由的操作系统，这个操作系统称为GNU。</p><blockquote><p>>小故事:<br>&emsp;相关的所有缩写的“G”均来自Gnu的首字母。gnu本来的意思是牛羚，也叫角马。GNU的吉祥物也正是角马。至于为什么选”Gnu”，斯托曼博士说当时他觉得好玩，他小时候听过一首歌，很喜欢，歌名是《The Gnu》</p></blockquote><p><strong>GPL</strong>：即GNU通用公共许可协议(GNU General Public License)，也叫GNU GPL，它有两个特点：</p><ol><li>一方面，它给予用户充分的自由，允许用户自由的运行、学习、共享和修改软件；</li><li>另一方面，它有一个严格的限制——GPL的派生作品也必须以GPL的许可形式发放；</li></ol><p>&emsp;通俗的说就是：软件随便用，源码也给你，随你怎么copy怎么修改，这都是你的自由，但是！你不能将大伙的劳动成果变成你一个人私有的！</p><blockquote><p>>小故事:<br>&emsp;从某种程度上说，GPL和GNU计划其实都源于当时兴起的软件著作权“copyright”。copyright的存在，让理查德等人在实际使用中感到诸多不便，为了打破这种限制和“不自由”，他发起了GNU计划，并撰写了许可协议GPL，让他所倡导的自由精神传续下去。不得不说，这种initiative spirit实在值得我们去学习。</p></blockquote><p>接下来介绍GNU和Linux：<br><strong>GNU</strong>：GNU的全称是GNU’s NOT UNIX，它本质上是一个自由的操作系统，其内容软件完全以GPL方式发布。我们现在提到GNU，一般是指这个操作系统，而不是GNU Project。</p><blockquote><p>>补充资料<br>&emsp;众所周知，开发操作系统是非常困难的一件事。UNIX作为一个非常强大且成熟的商用操作系统，虽然理查德不喜欢它的商业限制，但迫于UNIX的强大生态，GNU依然不得不去实现UNIX的标准接口。直到1990年，GNU计划已经开发出的软件包括一个功能强大的文字编辑器Emacs、C语言编译器GCC以及大部分UNIX系统的程序库和工具。但最重要的操作系统内核部分依然没有完成。此时，另一个天才Linux出现了。</p></blockquote><p><strong>Linux</strong>：Linux系统于1991年发布，据说他的作者，时年21岁的Linux开发这个系统的本意只是为了更好的下载学校资源。虽然Linux本人当时开发出来的只有<strong>Linux内核</strong>（即<strong>只具备与硬件打交道的能力</strong>，其他人性化的功能全都没有，比如GUI等）但由于Linux与Unix兼容且在GPL下发布，所以Linux在网络上流传非常快。后来，经过全世界程序员的积极贡献，基于当初的Linux内核，已经有了诸如 <strong>Ubuntu</strong> 这样的优秀发行版本。</p><p>现在我们已经知道了GNU project、GPL、以及GNU和Linux的渊源，那么，实际开发中我们常用到的gcc、g++、MinGW又是什么东西呢？<br><strong>gcc</strong>：全称为GNU Compiler Collection，是GNU编译器套装。需要注意的是，<strong>gcc是一个完整的套件</strong>，包含编译前端、汇编器、归档器、连接器，以及所支持的各个语言的库等。gcc原本叫做GNU C Compiler，因为最初只能编译C语言。此后gcc迅速得到扩展，开始支持C++，再后来已经可以处理Pascal、Objective-C、JAVA、Go等多种语言。由于gcc的巨大影响力(<strong>特别是其中的C语言编译器</strong>)，它常被认为是跨平台编译器的事实标准。在很多操作系统，包括很多“类UNIX系统”中，都将gcc作为标准编译器。</p><p><strong>g++</strong>：g++是gcc的c++编译器</p><p><strong>MinGW</strong>：MinGW全称是Minimalist GNU for Windows。顾名思义，MinGW实质上是GNU在windows系统的一个移植版本。所谓minimalist，就是指<strong>这个移植版本只包含针对C/C++的编译器工具集</strong>。此外，类似的移植版本还有cygwin和Djgpp，这里不做介绍。</p><h2 id="chapter-2-VScode"><a href="#chapter-2-VScode" class="headerlink" title="chapter 2 - VScode"></a>chapter 2 - VScode</h2><ol><li><p>下载和安装：官网免费下载，安装时选择添加到path；</p></li><li><p>汉化：安装后在VSCode扩展中安装Chinese插件</p></li><li><p>C/C++相关部分：</p><blockquote><p>I. VSCode扩展安装C/C++插件和code runner插件；后者需要设置ignore selection 和  run in terminal<br>II. 本机安装和配置MinGW:</p><blockquote><p>下载时，官网选择x86_64-posix-seh，本地解压即可；解压时我使用的软件是7-zip;<br>在系统变量的path中添加mingw主目录中的bin和include；<br>cmd测试安装配置结果：gcc -v -E -x c++ -</p></blockquote><p>III. 在VSCode的工程项目中新建一个.vscode文件(后续代码源文件也放在此.vscode文件中)，然后在此文件中添加三个配置文件：c_cpp_propertise.json、launch.json、tasks.json。注意修改其中的路径为本机安装的mingw的gcc或g++下设的相应文件，gcc针对C项目，g++针对C++项目。（配置文件的具体内容保存在本地了，这里不展开）<br>IV.注意事项：win的路径复制下来是\，会被当作转义符处理，在VSCode中配置路径时要改为\\或者/，这一点是VSCode配置中常见的错误。</p></blockquote></li><li><p>运行/调试：右上角Run Code/其他相应选项</p></li><li><p>关于VScode的json文件中无法添加注释的问题：</p><blockquote><p>在JSON中，使用以下两种方式来表示数据：<br>I. Object（对象）：键值对的集合，使用花括号{ }定义。在每个键值对中，以键开头，后跟一个冒号，最后是值。多个键值对之间使用逗号,分隔，例如{“name”:”blog”,”url”:”xx.xx.xx”}；<br>II. Array（数组）：值的有序集合，使用方括号[ ]定义，数组中每个值之间使用逗号进行分隔。<br>VSCode中如果想在json文件加注释，可以将底部蓝色状态栏中的语言模式设置为Json with Comments；</p></blockquote></li><li><p>字体间距变大问题解决：terminal.integrated.fontFamily设置为monospace</p></li><li><p>VSCode实用插件</p><blockquote><p><strong>markdown preview enhanced</strong>：编写markdown，上方状态栏打开侧边预览即可边写边预览<br><strong>partial diff</strong>：查看代码差异，选中一段后右键select text for cmp，再选中另一段cmp with previous<br><strong>markmap</strong>：绘制思维导图；类似markdown的语法，用’#’控制即可；上方状态栏open as markmap查看效果；</p></blockquote></li></ol><h2 id="chapter-3-Virsual-Studio"><a href="#chapter-3-Virsual-Studio" class="headerlink" title="chapter 3 - Virsual Studio"></a>chapter 3 - Virsual Studio</h2><p>VS使用起来比较笨重，有些配置不对会导致程序执行失败，比如找不到指定文件等，这个错误主要是没有生成.exe文件，可能是编译失败等原因，可以具体问题具体解决。这一块我暂时还没有完全搞清楚，后面用的多了再补。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA Encryption Algorithm</title>
      <link href="/2023/02/19/RSA%20Encryption%20Algorithm/"/>
      <url>/2023/02/19/RSA%20Encryption%20Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h3 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h3><p>Miller-Rabin测试、快速幂、扩展欧几里得算法、欧拉函数、欧拉公式、同余式、乘法逆元、密钥、公钥、私钥</p><p>为了方便理解，这里先简单介绍上述知识的意义：</p><blockquote><p><strong>Miller-Rabin测试</strong>：用于测试一个数是否为质数；单次测试存在小概率误判可能，即让一个非质数通过测试；可以使用不同参数做多次独立测试，让误判概率小到忽略不计；<br><strong>快速幂</strong>：把幂次用二进制形式表示来计算，可以在$O(log_2 N)$复杂度完成幂运算；<br><strong>扩展欧几里得算法</strong>：用于求解二元一次方程，得到一组解；<br><strong>欧拉函数</strong>：$\phi(n)$，表示小于 n 的正整数中，与 n 互质的数的个数(最大公因数为 1 的数的个数)。显然，如果 n 为质数，则$\phi(n)=n-1$;可以证明：若有<strong>两个质数P、Q</strong>，且$P\times Q=n$，则：</p><script type="math/tex; mode=display">\phi(n)=\phi(P\times Q)=\phi(P)\times\phi(Q)=(P-1)\times (Q-1)</script><p><strong>欧拉公式</strong>：若 $\alpha$ 与 n 互质，则左式与 1 关于n同余，即：</p><script type="math/tex; mode=display">\alpha^{\phi(n)}\equiv 1 \ (mod\ n)</script><p><strong>同余式</strong>：二元运算符 “$\equiv$”，表示左右操作数关于指定的模同余；”$\equiv$”具有 <strong><em>传递性</em></strong> 、可加性、<strong><em>可乘性</em></strong>；即，若 a 与 b 关于 m 同余，c 与 d 关于 m 同余，则：</p><script type="math/tex; mode=display">a+c\equiv b+d</script><script type="math/tex; mode=display">a\times c \equiv b\times d</script><p><strong>乘法逆元</strong>：若 $a \times b \equiv 1(modm)$，则 a 与 b 互相称为彼此关于 m 的乘法逆元；<br><strong>密钥</strong>：用于对称加密方式，表示明文和密文的转换规则；在对称加密方式下，转换使用的是同一套规则，一旦规则被第三方获知，就会存在泄密风险<br><strong>公钥</strong>：用于非对称加密方式，表示加密的规则，公钥被第三方获知不存在安全风险；<br><strong>私钥</strong>：用于非对称加密方式，表示解密规则，私钥的保管非常重要，一旦泄露就有泄密风险。<br><strong>补充说明</strong>：关于可逆加密和<strong>不可逆加密</strong>：对称和非对称都是可逆的，即可以根据某种规则从密文解出明文；不可逆加密是指，明文转化为密文由系统执行，一旦转化为密文，则不可能在合理时间内解出明文。这种加密方式一般用于口令加密，只有重新输入明文，并再次经过同样不可逆的加密算法处理，得到相同的加密密文并被系统重新识别后，才能真正解密。</p></blockquote><p><strong>快速幂计算方法</strong>：<br><img src="/medias/blog/快速幂.png" alt="快速幂" title="快速幂"></p><h3 id="2-算法背景"><a href="#2-算法背景" class="headerlink" title="2. 算法背景"></a>2. 算法背景</h3><p>网络上流传着这样一句话，RSA算法是地球上最重要的算法，没有之一。因为如果没有RSA算法，现在的网络世界就毫无安全可言，所有数据都是可通过技术手段被窃取的，也就不会产生信任和交易。想要理解RSA算法的重要性，就要先解释<code>对称加密算法</code>和<code>非对称加密算法</code>的概念。<br>在1976年以前，所有加密方法都使用<strong>对称加密算法</strong>：加密和解密使用同一套规则。例如：甲使用密钥 A 加密，将密文传递给乙，乙仍使用密钥 A 解密。如果密钥 A 在甲传递给乙的过程中泄露，或者根据已知的密文和明文的对应规律推导出密钥 A，则甲乙之间的通讯将毫无秘密可言。<br>1976年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不传递密钥的情况下，完成解密。这被称为<strong>Diffie-Hellman密钥交换算法</strong>。假如甲要和乙通讯，甲使用公钥 A 加密，将密文传递给乙，乙使用私钥 B 解密得到明文。其中<strong>公钥在网络上传递，私钥只有乙自己拥有</strong>，不在网络上传递。这样即使知道了公钥 A 也无法解密，反过来通讯也一样。只要私钥不泄漏，通信就是安全的，这就是<strong>非对称加密算法</strong>。<br>1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。</p><h3 id="3-RSA的原理"><a href="#3-RSA的原理" class="headerlink" title="3. RSA的原理"></a>3. RSA的原理</h3><h4 id="I-RSA公钥"><a href="#I-RSA公钥" class="headerlink" title="I. RSA公钥"></a>I. RSA公钥</h4><blockquote><p>RSA公钥可表示为<code>(n,e)</code>，其中，$n=P \times Q$，P、Q均为质数，且P、Q越大越安全。实际使用中，n的二进制位数要达到1024位，对于特别重要的场合，要达到2048位。e 是一个随机生成的质数，要求 e 满足：<br>$1&lt;e&lt;\phi(n)$，且 e 与 $\phi(n)$ 互质。</p></blockquote><h4 id="II-RSA私钥"><a href="#II-RSA私钥" class="headerlink" title="II. RSA私钥"></a>II. RSA私钥</h4><blockquote><p>RSA私钥可以表示为<code>(n,d)</code>，其中，d 是由扩展欧几里得法求解二元一次方程得出的一个解（一组解中的任意一个）。该二元一次方程由以下规则产生：$(e\times d)\ \%\ \phi(n) = 1$，即 $(e\times d)-1 = y\times \phi(n)$</p></blockquote><h4 id="III-加解密过程"><a href="#III-加解密过程" class="headerlink" title="III. 加解密过程"></a>III. 加解密过程</h4><blockquote><p>加密：</p><script type="math/tex; mode=display">(明文)^e\ \%\ n = (密文)</script><p>解密：</p><script type="math/tex; mode=display">(密文)^d\ \%\ n = (明文)</script></blockquote><h4 id="IV-为什么安全？"><a href="#IV-为什么安全？" class="headerlink" title="IV. 为什么安全？"></a>IV. 为什么安全？</h4><p>&emsp;RSA算法允许公钥 (n,e) 被获知，我们假设最糟糕的情况：n、e 和密文均已被第三方获知，此时他仍然不知道 P、Q 和 d。如果他想要破译，由加密规则可知，无法直接逆运算。而如果想得到 d，则需要先知道 $\phi(n)$，求 $\phi(n)$ 需要知道 P 和 Q（这也是为什么 <strong>RSA算法需要n取一个非常大的数的原因</strong>，否则不用知道 P 和 Q 就可以直接暴力解$\phi(n)$）。然而，对超大整数做因数分解是数学界公认的一个难题，这个难度决定了 RSA 的可靠性。如果依靠暴力法解 P、Q 或者 $ \phi(n) $，这个时间复杂度为指数级，按现有最大运算速度，要算很多年才能破解，因此 RSA 是安全的。</p><h3 id="4-RSA的过程"><a href="#4-RSA的过程" class="headerlink" title="4. RSA的过程"></a>4. RSA的过程</h3><blockquote><p>I. &thinsp;&thinsp;本地用MR测试生成超大的 P、Q，并以此求出 n。<br>II. &thinsp;本地按规则随机生成 e。<br>III. 利用扩展欧几里得法，本地求 e 关于 $\phi(n)$ 的乘法逆元 d。即：</p><script type="math/tex; mode=display">e\times d \equiv 1\ (mod\ \phi(n))</script></blockquote><p>&emsp;此时公钥和私钥均已构建完毕，但为什么就可以加密和解密呢？我们举个例子来看看。</p><blockquote><p>设某明文 $\alpha$ 与 n 互质，由欧拉公式：</p><script type="math/tex; mode=display">\alpha^{\phi(n)}\equiv 1\ (mod\ n)</script><p>由可乘性：</p><script type="math/tex; mode=display">\alpha^{k\phi(n)+1}\equiv \alpha\ (mod\ n)</script><p>由 d 的定义，也就是说：</p><script type="math/tex; mode=display">\alpha^{ed}\equiv \alpha\ (mod\ n)</script><p>由加密法则 $\alpha^e\ \%\ n = C$ 可知，密文 C 满足：</p><script type="math/tex; mode=display">C\equiv \alpha^e\ (mod\ n)</script><p>则：</p><script type="math/tex; mode=display">C^d\equiv \alpha^{ed}\equiv\alpha\ (mod\ n)</script><p>因此：</p><script type="math/tex; mode=display">C^d\ \%\ n = \alpha</script></blockquote><h3 id="5-补充说明"><a href="#5-补充说明" class="headerlink" title="5. 补充说明"></a>5. 补充说明</h3><p>RSA一般作为外层加密算法，为对称加密算法的密钥做加密；此外，由于P、Q实际取值时相差不会太大，RSA的可破解性还有待商榷。<br><strong>为什么要求e与$\phi(n)$互斥？</strong> 因为只有这样才能保证e的逆（私钥）唯一存在。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rsa </tag>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operation Brochure</title>
      <link href="/2023/02/18/Operation%20Brochure/"/>
      <url>/2023/02/18/Operation%20Brochure/</url>
      
        <content type="html"><![CDATA[<h2 id="HEXO-使用"><a href="#HEXO-使用" class="headerlink" title="HEXO-使用"></a>HEXO-使用</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To create a new post (or page, draft), post is the default layout, but you can supply your own. You can change the default layout by editing the default_layout setting in _config.yml<br>注：hexo new会依据选定的模板生成一个文件夹，文件夹内自动产生一个模板格式的md。例如我的博客中categorise目录下的index.md文件。</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Initialize-Hexo-Directory"><a href="#Initialize-Hexo-Directory" class="headerlink" title="Initialize Hexo Directory"></a>Initialize Hexo Directory</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：不指定 root 时将当前目录视为 root 并进行初始化，指定 root 会创建并初始化 hexo 博客根目录。</p><h3 id="Clean-Public-and-Database"><a href="#Clean-Public-and-Database" class="headerlink" title="Clean Public and Database"></a>Clean Public and Database</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：该命令会清除数据库文件和public文件夹。数据库文件和public都是执行<code>hexo g</code>或<code>hexo s</code>后生成的。如果我们在生成博客后，打开项目去搜索某个值，你会发现有很多相同内容出现在 public 目录下的文件以及<code>db.json</code>中。这些就是实际运行时产生的文件。一般配置做了改动后需要重新生成或者部署时要先 clean 一次。</p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Generating static files with Hexo is quite easy and fast.<br>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server <span class="token punctuation">[</span>-i<span class="token punctuation">]</span><span class="token punctuation">[</span>-p<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：In static mode（default）, only files in the public folder will be served and file watching is disabled. You have to run hexo generate before starting the server. Usually used in production.</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：需要先配置好git，并安装hexo的git插件。执行<code>hexo d</code>命令需要先生成。如果不是第一次部署，最好先clean。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此外，还需要修改博客根目录下的_config.yml文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: https://github.com/ryj921/ryj921.github.io  branch: main  <span class="token comment"># black lives matter事件后，GitHub主分支由master改为main</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Math-Latex"><a href="#Math-Latex" class="headerlink" title="Math Latex"></a>Math Latex</h3><p>由于存在语义冲突，导致有些时候数学公式不能正常显示。Hexo默认使用<code>hexo-renderer-marked</code>引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签。比如<code>下划线_</code>会被渲染引擎处理为<code>&lt;em&gt;</code>标签。<br>因为类 Latex 格式书写的数学公式下划线表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括<code>*, &#123;, &#125;, \\</code>等。<br>解决方案：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先卸掉原来的引擎：</span>$ <span class="token function">npm</span> uninstall hexo-renderer-marked <span class="token parameter variable">--save</span><span class="token comment"># 然后装新的：</span>$ <span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-kramed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换引擎后行间公式可以正确渲染了，但行内公式仍然存在语义冲突。<br>解决方案：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 博客根目录，找node_modules\kramed\lib\rules\inline.js</span>$ escape: /^<span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token variable"><span class="token variable">`</span>*<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#$+\-.!_>])/, #旧</span>$ escape: /^<span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token variable">`</span></span>*<span class="token punctuation">\</span><span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#$+\-.!_>])/,     #新</span><span class="token comment"># 再改20行的em:</span>$ em: /^<span class="token punctuation">\</span>b_<span class="token punctuation">((</span>?:__<span class="token operator">|</span><span class="token punctuation">[</span><span class="token punctuation">\</span>s<span class="token punctuation">\</span>S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>_<span class="token punctuation">\</span>b<span class="token operator">|</span>^<span class="token punctuation">\</span>*<span class="token punctuation">((</span>?:<span class="token punctuation">\</span>*<span class="token punctuation">\</span>*<span class="token operator">|</span><span class="token punctuation">[</span><span class="token punctuation">\</span>s<span class="token punctuation">\</span>S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span><span class="token punctuation">\</span>*<span class="token punctuation">(</span>?<span class="token operator">!</span><span class="token punctuation">\</span>*<span class="token punctuation">)</span>/, <span class="token comment">#旧</span>$ em: /^<span class="token punctuation">\</span>*<span class="token punctuation">((</span>?:<span class="token punctuation">\</span>*<span class="token punctuation">\</span>*<span class="token operator">|</span><span class="token punctuation">[</span><span class="token punctuation">\</span>s<span class="token punctuation">\</span>S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span><span class="token punctuation">\</span>*<span class="token punctuation">(</span>?<span class="token operator">!</span><span class="token punctuation">\</span>*<span class="token punctuation">)</span>/,                          <span class="token comment">#新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Blog-About"><a href="#Blog-About" class="headerlink" title="Blog-About"></a>Blog-About</h2><h3 id="博客框架简介"><a href="#博客框架简介" class="headerlink" title="博客框架简介"></a>博客框架简介</h3><p>Blog搭建的方式可以分为静态博客和动态博客。<br><strong>静态博客</strong>：博文内容是通过文档（如：.md文件等）记录的一个独立的文件，通过生成工具编译成最终的html、css、js等静态文件，然后部署在静态Server服务器上或Web托管至数据仓库（如：Github）。<br><strong>动态博客</strong>：以数据库技术为基础，其博文内容是通过数据库记录存储的，主要特点体现在交互性；动不是指网页中的页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登录、评论、用户管理等）。<br><strong>总结</strong>：静态博客无需数据库支撑，而动态博客的“动”恰恰体现在与数据库的交互上。</p><p>常用静态博客框架：</p><blockquote><p><a href="https://hexo.io/zh-cn/">Hexo</a>、<a href="https://www.gohugo.cn/">Hugo</a>、<a href="https://www.vuepress.cn/">VuePress</a>、<a href="https://www.jekyll.com.cn/">Jekyll</a></p></blockquote><p>常用动态博客框架</p><blockquote><p><a href="https://wordpress.org/">WordPress</a>、<a href="https://typecho.org/">Typecho</a>、<a href="https://halo.run/">Halo</a>、<a href="https://b3log.org/solo/">Solo</a></p></blockquote><h3 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h3><p>在学习和实践中总结出来的的东西记录在博文里，这是里子。美观便捷的UI界面，这是面子。里子实在，面子光鲜。HEXO作为一个成熟的静态博客框架，经过诸多编程者的开发贡献，已经有了很多美观而可用的博客框架。我们在<a href="https://hexo.io/themes/">hexo主题</a>中可以根据个人喜好选择合适的主题框架进行配置。<br>大部分主题从 github 上下载后，<strong>添加到博客根目录下的 theme 文件夹下，并修改根目录配置文件 _config.yml 中的 theme 的值为对应文件名</strong>即可使用。<br>我目前接触过的主题有：hexo默认landscape、yilia、sakura和现在使用的matery。其中sakura的配置较为复杂，并且加载需要依赖 cdn 技术。Sakura主题<strong>使用jsDelivr + github搭建CDN</strong>，但由于 jsDelivr 的国内 IP 被停用，所以最终放弃了搭建该主题。</p><h2 id="Matery-配置"><a href="#Matery-配置" class="headerlink" title="Matery-配置"></a>Matery-配置</h2><h3 id="Directory-Introduction"><a href="#Directory-Introduction" class="headerlink" title="Directory Introduction"></a>Directory Introduction</h3><div class="table-container"><table><thead><tr><th>目录</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>node_modules</td><td><code>hexo init</code>后生成，放置hexo相关的内容</td><td>不用动</td></tr><tr><td>public</td><td><code>hexo s</code>或<code>hexo g</code>后自动生成，用于server启动</td><td>不用动</td></tr><tr><td>scaffolds</td><td>模板，内含<code>draft</code>、<code>page</code>、<code>post</code>三种模板</td><td>一般不动</td></tr><tr><td>source</td><td>我们博客的内容所在的文件夹，其中<code>_posts</code>存放我们写好的博客 markdown 文件，默认会有一个helloWorld</td><td>Matery主题需要<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">配置其他内容目录</a></td></tr><tr><td>themes</td><td>存放主题相关内容</td><td>非常重要，需要修改很多</td></tr><tr><td>_config.yml</td><td>博客根目录配置文件，设定title、author、时间信息、deploy配置、theme、插件相关信息等</td><td>根据需要自己改</td></tr><tr><td>主题的source</td><td>根目录的themes中的matery中的source；可以把这个source理解为博客实际运行时的<code>根目录</code>；添加图片等本地资源时都使用从此处开始的路径；例如/medias/images/01.jpg；</td><td>本地资源添加到此文件夹下的<code>medias</code>中</td></tr><tr><td>主题config.yml</td><td>根目录的themes中的matery中的<code>_config.yml</code>；包含该主题个性化配置的相关内容；</td><td>根据需要自己<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">修改对应配置</a></td></tr></tbody></table></div><h3 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front-Matter"></a>Front-Matter</h3><p>Front-Matter是博客文章开头针对本文设置的配置信息，下面的例子中包含了所有的常用配置项，具体使用时可以根据实际需求。注意，正常来说，开启的功能越多，渲染所需时间就越久，加载所需时间也会更长。如有疑问，可以参考<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">配置文档</a>。若文档信息失效，可以查看本地文件中，Matery下的<code>README_CN.md</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: exampledate: <span class="token number">2023</span>-02-18 <span class="token number">16</span>:47:28author: Yujia Rongimg: <span class="token punctuation">\</span>medias<span class="token punctuation">\</span>featureimages<span class="token punctuation">\</span><span class="token number">4</span>.jpgtop: <span class="token boolean">false</span>hide: <span class="token boolean">false</span>cover: <span class="token boolean">false</span>coverImg: /medias/featureimages/18.jpgpassword: toc: <span class="token boolean">true</span>mathjax: <span class="token boolean">false</span>summary: Welcome to my blog<span class="token operator">!</span> This is my very first post to introduce the usage of frame HEXO and to illuminate the configuration of Theme-Matery. check <span class="token keyword">for</span> <span class="token function">more</span> info.categories: tutorialtags: <span class="token punctuation">[</span>hexo, markdown, theme-matery<span class="token punctuation">]</span>keywords: reprintPolicy: cc_by---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置说明：</p><blockquote><p>title、date建议每次都设定；date 建议每篇文章唯一，因为本主题的<code>Gitalk</code>和<code>Gitment</code>是以date作为唯一标识<code>id</code>的。<br>img 表示这篇博客在网站上的封面，如果不设置则会根据标题的<code>hashCode</code>取余，然后从默认文件中选取；(\medias\featureimages中的图)<br>top 表示是否置顶；<br>hide 表示是否隐藏；<br>cover 表示是否添加到网站顶部的循环滚动栏；<br>coverImg 表示滚动栏此页的背景图，不设置默认用此博客的featureImage；<br>password 需要先使用<code>SHA256</code>加密，否则可以通过查看源代码获取此密码；<br>toc 是博客页内导航栏，建议开启；<br>mathjax 受hexo支持，不添加Latex数学公式时建议关闭，以减少渲染时间；<br>summary 是文章在封面显示的摘要内容，不设置则默认摘取一段；<br>categories 在写每篇文章时自己设定，本主题根据此项来分类，并使用配置好的categories功能；分类具有顺序性和层次性，即区分父分类和子分类。例如<code>[A, B]</code>不等于<code>[B, A]</code>；<br>tag 为文章添加标签，与categories不同，标签没有顺序和层次性；<br>keyword 关键字；<br>reprintPolicy 知识共享许可协议(Creative Commons license)，又叫<code>CC协议</code>，是一种允许他人分发作品的公共版权许可。cc_by是使用最自由的一种协议，一般就用这个；</p></blockquote><p>注：<strong>图片放在theme下的medias中，使用时格式为：/medias/XXX（注意，一定要使用 ‘ / ‘，不可以用反斜杠）</strong></p><h3 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h3><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery" title="origin of theme-matery">hexo-theme-matery源站</a>；</li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README.md" title="Matery Configuration">hexo-theme-matery源文档</a>；</li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery中文文档">hexo-theme-matery中文文档</a>；</li><li><a href="https://hexo.io/themes/" title="hexo主题">hexo主题</a>；</li></ul>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
            <tag> theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
