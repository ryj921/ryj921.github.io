<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2023/02/19/test/"/>
      <url>/2023/02/19/test/</url>
      
        <content type="html"><![CDATA[<p>测试图片：</p><p><img src="/test.png" alt="test" title="test"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Operation Brochure</title>
      <link href="/2023/02/18/Operation-Brochure/"/>
      <url>/2023/02/18/Operation-Brochure/</url>
      
        <content type="html"><![CDATA[<h2 id="HEXO-使用"><a href="#HEXO-使用" class="headerlink" title="HEXO-使用"></a>HEXO-使用</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To create a new post (or page, draft), post is the default layout, but you can supply your own. You can change the default layout by editing the default_layout setting in _config.yml<br>注：hexo new会依据选定的模板生成一个文件夹，文件夹内自动产生一个模板格式的md。例如我的博客中categorise目录下的index.md文件。</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Initialize-Hexo-Directory"><a href="#Initialize-Hexo-Directory" class="headerlink" title="Initialize Hexo Directory"></a>Initialize Hexo Directory</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：不指定 root 时将当前目录视为 root 并进行初始化，指定 root 会创建并初始化 hexo 博客根目录。</p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Generating static files with Hexo is quite easy and fast.<br>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server <span class="token punctuation">[</span>-i<span class="token punctuation">]</span><span class="token punctuation">[</span>-p<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：In static mode（default）, only files in the public folder will be served and file watching is disabled. You have to run hexo generate before starting the server. Usually used in production.</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：需要先配置好git，并安装hexo的git插件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此外，还需要修改博客根目录下的_config.yml文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: https://github.com/ryj921/ryj921.github.io  branch: main  <span class="token comment"># black lives matter事件后，GitHub主分支由master改为main</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Blog-About"><a href="#Blog-About" class="headerlink" title="Blog-About"></a>Blog-About</h2><h3 id="博客框架简介"><a href="#博客框架简介" class="headerlink" title="博客框架简介"></a>博客框架简介</h3><p>Blog搭建的方式可以分为静态博客和动态博客。<br><strong>静态博客</strong>：博文内容是通过文档（如：.md文件等）记录的一个独立的文件，通过生成工具编译成最终的html、css、js等静态文件，然后部署在静态Server服务器上或Web托管至数据仓库（如：Github）。<br><strong>动态博客</strong>：以数据库技术为基础，其博文内容是通过数据库记录存储的，主要特点体现在交互性；动不是指网页中的页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登录、评论、用户管理等）。<br><strong>总结</strong>：静态博客无需数据库支撑，而动态博客的“动”恰恰体现在与数据库的交互上。</p><p>常用静态博客框架：</p><blockquote><p><a href="https://hexo.io/zh-cn/">Hexo</a>、<a href="https://www.gohugo.cn/">Hugo</a>、<a href="https://www.vuepress.cn/">VuePress</a>、<a href="https://www.jekyll.com.cn/">Jekyll</a></p></blockquote><p>常用动态博客框架</p><blockquote><p><a href="https://wordpress.org/">WordPress</a>、<a href="https://typecho.org/">Typecho</a>、<a href="https://halo.run/">Halo</a>、<a href="https://b3log.org/solo/">Solo</a></p></blockquote><h3 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h3><p>在学习和实践中总结出来的的东西记录在博文里，这是里子。美观便捷的UI界面，这是面子。里子实在，面子光鲜。HEXO作为一个成熟的静态博客框架，经过诸多编程者的开发贡献，已经有了很多美观而可用的博客框架。我们在<a href="https://hexo.io/themes/">hexo主题</a>中可以根据个人喜好选择合适的主题框架进行配置。<br>大部分主题从 github 上下载后，<strong>添加到博客根目录下的 theme 文件夹下，并修改根目录配置文件 _config.yml 中的 theme 的值为对应文件名</strong>即可使用。<br>我目前接触过的主题有：hexo默认landscape、yilia、sakura和现在使用的matery。其中sakura的配置较为复杂，并且加载需要依赖 cdn 技术。Sakura主题<strong>使用jsDelivr + github搭建CDN</strong>，但由于 jsDelivr 的国内 IP 被停用，所以最终放弃了搭建该主题。</p><h2 id="Matery-配置"><a href="#Matery-配置" class="headerlink" title="Matery-配置"></a>Matery-配置</h2><h3 id="Directory-Introduction"><a href="#Directory-Introduction" class="headerlink" title="Directory Introduction"></a>Directory Introduction</h3><table><thead><tr><th>目录</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>node_modules</td><td><code>hexo init</code>后生成，放置hexo相关的内容</td><td>不用动</td></tr><tr><td>public</td><td><code>hexo s</code>或<code>hexo g</code>后自动生成，用于server启动</td><td>不用动</td></tr><tr><td>scaffolds</td><td>模板，内含<code>draft</code>、<code>page</code>、<code>post</code>三种模板</td><td>一般不动</td></tr><tr><td>source</td><td>我们博客的内容所在的文件夹，其中<code>_posts</code>存放我们写好的博客 markdown 文件，默认会有一个helloWorld</td><td>Matery主题需要<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">配置其他内容目录</a></td></tr><tr><td>themes</td><td>存放主题相关内容</td><td>非常重要，需要修改很多</td></tr><tr><td>_config.yml</td><td>博客根目录配置文件，设定title、author、时间信息、deploy配置、theme、插件相关信息等</td><td>根据需要自己改</td></tr><tr><td>主题的source</td><td>根目录的themes中的matery中的source；可以把这个source理解为博客实际运行时的<code>根目录</code>；添加图片等本地资源时都使用从此处开始的路径；例如&#x2F;medias&#x2F;images&#x2F;01.jpg；</td><td>本地资源添加到此文件夹下的<code>medias</code>中</td></tr><tr><td>主题config.yml</td><td>根目录的themes中的matery中的<code>_config.yml</code>；包含该主题个性化配置的相关内容；</td><td>根据需要自己<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">修改对应配置</a></td></tr></tbody></table><h3 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front-Matter"></a>Front-Matter</h3><p>Front-Matter是博客文章开头针对本文设置的配置信息，下面的例子中包含了所有的常用配置项，具体使用时可以根据实际需求。注意，正常来说，开启的功能越多，渲染所需时间就越久，加载所需时间也会更长。如有疑问，可以参考<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery配置中文文档">配置文档</a>。若文档信息失效，可以查看本地文件中，Matery下的<code>README_CN.md</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: exampledate: <span class="token number">2023</span>-02-18 <span class="token number">16</span>:47:28author: Yujia Rongimg: <span class="token punctuation">\</span>medias<span class="token punctuation">\</span>featureimages<span class="token punctuation">\</span><span class="token number">4</span>.jpgtop: <span class="token boolean">false</span>hide: <span class="token boolean">false</span>cover: <span class="token boolean">false</span>coverImg: /medias/featureimages/18.jpgpassword: toc: <span class="token boolean">true</span>mathjax: <span class="token boolean">false</span>summary: Welcome to my blog<span class="token operator">!</span> This is my very first post to introduce the usage of frame HEXO and to illuminate the configuration of Theme-Matery. check <span class="token keyword">for</span> <span class="token function">more</span> info.categories: tutorialtags: <span class="token punctuation">[</span>hexo, markdown, theme-matery<span class="token punctuation">]</span>keywords: reprintPolicy: cc_by---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置说明：</p><blockquote><p>title、date建议每次都设定；date 建议每篇文章唯一，因为本主题的<code>Gitalk</code>和<code>Gitment</code>是以date作为唯一标识<code>id</code>的。<br>img 表示这篇博客在网站上的封面，如果不设置则会根据标题的<code>hashCode</code>取余，然后从默认文件中选取；(\medias\featureimages中的图)<br>top 表示是否置顶；<br>hide 表示是否隐藏；<br>cover 表示是否添加到网站顶部的循环滚动栏；<br>coverImg 表示滚动栏此页的背景图，不设置默认用此博客的featureImage；<br>password 需要先使用<code>SHA256</code>加密，否则可以通过查看源代码获取此密码；<br>toc 是博客页内导航栏，建议开启；<br>mathjax 受hexo支持，不添加Latex数学公式时建议关闭，以减少渲染时间；<br>summary 是文章在封面显示的摘要内容，不设置则默认摘取一段；<br>categories 在写每篇文章时自己设定，本主题根据此项来分类，并使用配置好的categories功能；分类具有顺序性和层次性，即区分父分类和子分类。例如<code>[A, B]</code>不等于<code>[B, A]</code>；<br>tag 为文章添加标签，与categories不同，标签没有顺序和层次性；<br>keyword 关键字；<br>reprintPolicy 知识共享许可协议(Creative Commons license)，又叫<code>CC协议</code>，是一种允许他人分发作品的公共版权许可。cc_by是使用最自由的一种协议，一般就用这个；</p></blockquote><h3 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h3><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery" title="origin of theme-matery">hexo-theme-matery源站</a>；</li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README.md" title="Matery Configuration">hexo-theme-matery源文档</a>；</li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="Matery中文文档">hexo-theme-matery中文文档</a>；</li><li><a href="https://hexo.io/themes/" title="hexo主题">hexo主题</a>；</li></ul>]]></content>
      
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
            <tag> theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/17/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Machine-Learning-amp-Deep-Learning"><a href="#Machine-Learning-amp-Deep-Learning" class="headerlink" title="Machine Learning &amp; Deep Learning"></a>Machine Learning &amp; Deep Learning</h1><hr><h2 id="chapter-1-基础知识"><a href="#chapter-1-基础知识" class="headerlink" title="chapter 1. 基础知识"></a>chapter 1. 基础知识</h2><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p><strong>Machine Learning ≈ Looking for a Correct Function</strong><br>eg.语音识别：f(语音信号) &#x3D; “How are you”<br>&amp;emsp;&amp;ensp;图像识别：f(图片) &#x3D; “cat”<br>&amp;emsp;&amp;ensp;alpha Go：f(棋盘) &#x3D; “下一步落子位置”<br><strong>f的正常编写会很困难，而机器学习就是帮我们找出：人写不出来的那个”复杂函数f”</strong></p><h3 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h3><p>要找的那个函数f是一个 <strong>“类神经网络”</strong></p><h3 id="机器学习的输入与输出"><a href="#机器学习的输入与输出" class="headerlink" title="机器学习的输入与输出"></a>机器学习的输入与输出</h3><p><strong>机器学习可以分为两大类任务，一类叫做regression，另一类叫做classificaton</strong><br>输入可以是一个vector、一个matrix（图片识别）或是一个sequence（语音辨识、翻译）<br>输出可以是一个数值scalar、一组类别或是更复杂的输出，如一篇文章等<br>输出是数值scalar的称为regression，即回归；例如数值预测；<br>输出是类别的，即为机器提供几个选项让他选择，称为分类classification；例如垃圾邮件识别，alpha-Go(所有落点选一个);</p><h3 id="机器如何自动的找出这个函数F"><a href="#机器如何自动的找出这个函数F" class="headerlink" title="机器如何自动的找出这个函数F"></a>机器如何自动的找出这个函数F</h3><p>Supervised Learning监督学习：在Training Data中设置label;缺点是要收集大量数据和设置标签，在实际中难以做到；<br>Self-supervised Learning自监督学习：在训练之前“先练成一些基本功”，即Pre-train预训练 + Downstream Tasks下游任务；<br>Pre-train和Downstream Tasks的关系就好像开发OS和开发APP的关系;<br>Pre-tarined Model也叫Foundation Model，其中最有名的就是BERT模型，有340个参数parameters（《芝麻街》中的小黄人）；此外还有：GPT-3、GPT-2、T5、ELMo；</p><h3 id="补充介绍"><a href="#补充介绍" class="headerlink" title="补充介绍"></a>补充介绍</h3><p><strong>generative adversarial network</strong>：将unpaired的数据输入让机器自己学习得出结果的一种技术；目前做的最好的是facebook的一篇论文：</p><blockquote><p><a href="https://arxiv.org/abs/2105.11084">https://arxiv.org/abs/2105.11084</a></p></blockquote><p><strong>reinforcement learning</strong>：强化学习，适用于难以打标签的场合；例如围棋，人很难知道下一步应该落在哪里是最好的，但我们可以告诉机器什么是好的结果，什么是不好的结果；<br><strong>anomaly detection</strong>：异常检测，让机器拥有回答”我不知道”的能力；<br><strong>explainable AI</strong>：可解释性AI，让机器不仅能输出结果，还要告诉我们为什么，以具有更好的可解释性；<br><strong>model attack</strong>:人类对训练模型的攻击；如插入杂讯；<br><strong>domain adaptation</strong>：域适应；针对实际接受的场景可能与训练场景有区别的情况；比如训练用的是黑白图片，实际变成彩色图片；<br><strong>network compression</strong>：模型压缩，从而让他们跑在更简单的设备上；例如手机、手表；<br><strong>life-long learning</strong>：让机器不断学习新技术会有什么困难？<br><strong>meta learning</strong>：meta learning &#x3D; learn to learn，即让机器学会学习；meta learning往往用于实现<strong>Few-shot learning</strong>，即采用非常少量的资料让机器学会目标；</p><h3 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h3><p>python、google colab<br>colab全称为Colaboratory,是免费的Jupyter运行环境,并且完全在云端运行。最重要的是免费，而且不需要你自己去装深度学习的环境</p><h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><p><a href="https://www.kaggle.com/">https://www.kaggle.com</a><br>一个机器学习的线上平台，包含了很多竞赛内容，部分竞赛甚至设有奖金；<br>项目做完后可以上传到kaggle上跑分，并获知排行；<br>public leaderboard在上传后就可以看到；包含一部分测试集；<br>private leaderboard要在deadline后；包含另一部分；</p><hr><h2 id="chapter-2-Regression"><a href="#chapter-2-Regression" class="headerlink" title="chapter 2. Regression"></a>chapter 2. Regression</h2><h3 id="什么是regression"><a href="#什么是regression" class="headerlink" title="什么是regression"></a>什么是regression</h3><p>the function outputs a scalar<br>例如，输入今天的气象参数到函数f，得出未来的pm2.5的值；</p><h3 id="Structured-Learning"><a href="#Structured-Learning" class="headerlink" title="Structured Learning"></a>Structured Learning</h3><p>即create something with structure(image、document)；用拟人化的方式来说，就是不只是让机器得出结果，还要让机器会创造。</p><h3 id="机器如何找出函数F（即训练过程）"><a href="#机器如何找出函数F（即训练过程）" class="headerlink" title="机器如何找出函数F（即训练过程）"></a>机器如何找出函数F（即训练过程）</h3><blockquote><p>“三步走”：</p><ol><li>写出一个带有未知参数的函数，即猜测一下我们需要预测的目标的数学关系式是什么样的。（eg.猜测明日油管播放量 y &#x3D; b + wx，x是今日播放量，b 和 w 是未知数，w 可以表示权重 weight，b 可以表示 bias）这个带有未知参数的函数也称为<strong>模型</strong>。</li><li>定义Loss：Loss也是一个Function，此function的输入是model的参数（eg.对于上面的举例，Loss可以表示为L(b,w)）。Loss这个Function输出的值的意义是衡量当前参数的取值好还是不好。一般的，Loss越小，说明取的参数越好。<br><strong>Loss的计算方式</strong>：MAE(mean absolute error)、MSE(mean square error)等；<br>注意：Loss是可以根据实际场景去自己定义的。</li><li>Optimization最佳化；即找出最好的 $w^{<em>}$ 和 $b^{</em>}$，使得Loss取最小值。<br>一个最常用的optimize的方法就是Gradient Descent，即<strong>梯度下降法</strong>。<br><strong>梯度下降法的步骤</strong>：<br>I. 先随机取一个点$w_0$；<br>II. 然后计算 $\frac{\partial L}{\partial w}|<em>{w&#x3D;w_0}$ ，如果为负，则增加w；如果为正，则减小w；<br>每次移动的值表示为 $\eta\frac{\partial L}{\partial w}|</em>{w&#x3D;w_0}$ ；即偏微分越大，移动越多；$\eta$ 称为<strong>learning rate</strong>，即学习率，$\eta$ 越大每次跳的越多，反之越小。它的值是由我们自己去定义的。像 $\eta$ 这样由我们设定而非机器去学习得来的参数称为 <strong>hyperparameter</strong>；<br>III. 接下来更新 w，即 $w_1&#x3D;w_0-\eta\frac{\partial L}{\partial w}|_{w&#x3D;w_0}$<br><strong>思考：为什么是减？</strong> 原因是我们希望找最小的L，当偏导为负时要增加，偏导为正时要减小；联系梯度下降的概念，实际上梯度是当前函数增加最快的方向，则 <strong>负梯度方向是函数减少最快的方向。</strong><br>IV. 持续移动 w 直到结束；<strong>结束条件</strong>可以是更新次数上限(hyperparameter)、微分值为零的点(<strong>局部最优解local minima</strong>)；</li></ol></blockquote><h3 id="关于方向导数和梯度的数学补充"><a href="#关于方向导数和梯度的数学补充" class="headerlink" title="关于方向导数和梯度的数学补充"></a>关于方向导数和梯度的数学补充</h3><p>关于方向导数：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/方向导数.PNG" alt="方向导数" title="方向导数"><br>关于梯度：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/梯度.PNG" alt="梯度" title="梯度"><br>多参数问题用Gradient Decent:<br><img src="D:/Desktop/我的文件/笔记/图片笔记/gradient_decent.png" alt="Gradient Decent" title="Gradient Decent"><br>实例：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/梯度下降实例.png" alt="实例" title="Gradient 梯度下降"></p><h3 id="模型修改"><a href="#模型修改" class="headerlink" title="模型修改"></a>模型修改</h3><p><strong>对模型的修改往往源于对于问题实际情况的深入理解，即Domain Knowledge</strong><br>一般来讲，在训练数据上考虑因素越多，在训练集上的Loss越小。例如，预测播放量中考虑前一天和考虑前七天的差异。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%80%81%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%80%81%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Missing-Semester"><a href="#Missing-Semester" class="headerlink" title="Missing Semester"></a>Missing Semester</h1><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>&amp;emsp;在麻省理工，有一门课程叫做missing semester，讲授如何高效的使用计算机工具。我想引用课程介绍中的一段话：“计算机是为自动化手工任务而生的，然而学生们却经常用手来完成重复性的任务。计算机生态系统知识，没有作为作为大学课程的一部分来教授。学生们从来没有被告知如何使用这些工具，或者至少没有被告知如何有效的使用这些工具，从而将精力和时间浪费在了本应简单的任务上”。趁着这段时间可以自由安排，我实践和学习了很多基础性的知识，算是补上自己缺失的一课。我将所学记录下来，于是便有了这篇博客。</p><h1 id="chapter-1-compiler"><a href="#chapter-1-compiler" class="headerlink" title="chapter 1 - compiler"></a>chapter 1 - compiler</h1><h3 id="GNU、gcc和MinGW"><a href="#GNU、gcc和MinGW" class="headerlink" title="GNU、gcc和MinGW"></a>GNU、gcc和MinGW</h3><p>首先了解GPL和GNU Project：<br><strong>GNU Project</strong>：革奴计划，是一个自由软件集体协作计划，1983年9月27日由理查德·斯托曼在麻省理工学院公开发起。它的目的是创建一套完全自由的操作系统，这个操作系统称为GNU。</p><blockquote><p>&gt;小故事:<br>&amp;emsp;相关的所有缩写的“G”均来自Gnu的首字母。gnu本来的意思是牛羚，也叫角马。GNU的吉祥物也正是角马。至于为什么选”Gnu”，斯托曼博士说当时他觉得好玩，他小时候听过一首歌，很喜欢，歌名是《The Gnu》</p></blockquote><p><strong>GPL</strong>：即GNU通用公共许可协议(GNU General Public License)，也叫GNU GPL，它有两个特点：</p><ol><li>一方面，它给予用户充分的自由，允许用户自由的运行、学习、共享和修改软件；</li><li>另一方面，它有一个严格的限制——GPL的派生作品也必须以GPL的许可形式发放；</li></ol><p>&amp;emsp;通俗的说就是：软件随便用，源码也给你，随你怎么copy怎么修改，这都是你的自由，但是！你不能将大伙的劳动成果变成你一个人私有的！</p><blockquote><p>&gt;小故事:<br>&amp;emsp;从某种程度上说，GPL和GNU计划其实都源于当时兴起的软件著作权“copyright”。copyright的存在，让理查德等人在实际使用中感到诸多不便，为了打破这种限制和“不自由”，他发起了GNU计划，并撰写了许可协议GPL，让他所倡导的自由精神传续下去。不得不说，这种initiative spirit实在值得我们去学习。</p></blockquote><p>接下来介绍GNU和Linux：<br><strong>GNU</strong>：GNU的全称是GNU’s NOT UNIX，它本质上是一个自由的操作系统，其内容软件完全以GPL方式发布。我们现在提到GNU，一般是指这个操作系统，而不是GNU Project。</p><blockquote><p>&gt;补充资料<br>&amp;emsp;众所周知，开发操作系统是非常困难的一件事。UNIX作为一个非常强大且成熟的商用操作系统，虽然理查德不喜欢它的商业限制，但迫于UNIX的强大生态，GNU依然不得不去实现UNIX的标准接口。直到1990年，GNU计划已经开发出的软件包括一个功能强大的文字编辑器Emacs、C语言编译器GCC以及大部分UNIX系统的程序库和工具。但最重要的操作系统内核部分依然没有完成。此时，另一个天才Linux出现了。</p></blockquote><p><strong>Linux</strong>：Linux系统于1991年发布，据说他的作者，时年21岁的Linux开发这个系统的本意只是为了更好的下载学校资源。虽然Linux本人当时开发出来的只有<strong>Linux内核</strong>（即<strong>只具备与硬件打交道的能力</strong>，其他人性化的功能全都没有，比如GUI等）但由于Linux与Unix兼容且在GPL下发布，所以Linux在网络上流传非常快。后来，经过全世界程序员的积极贡献，基于当初的Linux内核，已经有了诸如 <strong>Ubuntu</strong> 这样的优秀发行版本。</p><p>现在我们已经知道了GNU project、GPL、以及GNU和Linux的渊源，那么，实际开发中我们常用到的gcc、g++、MinGW又是什么东西呢？<br><strong>gcc</strong>：全称为GNU Compiler Collection，是GNU编译器套装。需要注意的是，<strong>gcc是一个完整的套件</strong>，包含编译前端、汇编器、归档器、连接器，以及所支持的各个语言的库等。gcc原本叫做GNU C Compiler，因为最初只能编译C语言。此后gcc迅速得到扩展，开始支持C++，再后来已经可以处理Pascal、Objective-C、JAVA、Go等多种语言。由于gcc的巨大影响力(<strong>特别是其中的C语言编译器</strong>)，它常被认为是跨平台编译器的事实标准。在很多操作系统，包括很多“类UNIX系统”中，都将gcc作为标准编译器。</p><p>**g++**：g++是gcc的c++编译器</p><p><strong>MinGW</strong>：MinGW全称是Minimalist GNU for Windows。顾名思义，MinGW实质上是GNU在windows系统的一个移植版本。所谓minimalist，就是指<strong>这个移植版本只包含针对C&#x2F;C++的编译器工具集</strong>。此外，类似的移植版本还有cygwin和Djgpp，这里不做介绍。</p><h1 id="chapter-2-VScode"><a href="#chapter-2-VScode" class="headerlink" title="chapter 2 - VScode"></a>chapter 2 - VScode</h1><ol><li><p>下载和安装：官网免费下载，安装时选择添加到path；</p></li><li><p>汉化：安装后在VSCode扩展中安装Chinese插件</p></li><li><p>C&#x2F;C++相关部分：</p><blockquote><p>I. VSCode扩展安装C&#x2F;C++插件和code runner插件；后者需要设置ignore selection 和  run in terminal<br>II. 本机安装和配置MinGW:</p><blockquote><p>下载时，官网选择x86_64-posix-seh，本地解压即可；解压时我使用的软件是7-zip;<br>在系统变量的path中添加mingw主目录中的bin和include；<br>cmd测试安装配置结果：gcc -v -E -x c++ -</p></blockquote><p>III. 在VSCode的工程项目中新建一个.vscode文件(后续代码源文件也放在此.vscode文件中)，然后在此文件中添加三个配置文件：c_cpp_propertise.json、launch.json、tasks.json。注意修改其中的路径为本机安装的mingw的gcc或g++下设的相应文件，gcc针对C项目，g++针对C++项目。（配置文件的具体内容保存在本地了，这里不展开）<br>IV.注意事项：win的路径复制下来是\，会被当作转义符处理，在VSCode中配置路径时要改为\或者&#x2F;，这一点是VSCode配置中常见的错误。</p></blockquote></li><li><p>运行&#x2F;调试：右上角Run Code&#x2F;其他相应选项</p></li><li><p>关于VScode的json文件中无法添加注释的问题：</p><blockquote><p>在JSON中，使用以下两种方式来表示数据：<br>I. Object（对象）：键值对的集合，使用花括号{ }定义。在每个键值对中，以键开头，后跟一个冒号，最后是值。多个键值对之间使用逗号,分隔，例如{“name”:”blog”,”url”:”xx.xx.xx”}；<br>II. Array（数组）：值的有序集合，使用方括号[ ]定义，数组中每个值之间使用逗号进行分隔。<br>VSCode中如果想在json文件加注释，可以将底部蓝色状态栏中的语言模式设置为Json with Comments；</p></blockquote></li><li><p>字体间距变大问题解决：terminal.integrated.fontFamily设置为monospace</p></li><li><p>VSCode实用插件</p><blockquote><p><strong>markdown preview enhanced</strong>：编写markdown，上方状态栏打开侧边预览即可边写边预览<br><strong>partial diff</strong>：查看代码差异，选中一段后右键select text for cmp，再选中另一段cmp with previous<br><strong>markmap</strong>：绘制思维导图；类似markdown的语法，用’#’控制即可；上方状态栏open as markmap查看效果；</p></blockquote></li></ol><h1 id="chapter-3-Virsual-Studio"><a href="#chapter-3-Virsual-Studio" class="headerlink" title="chapter 3 - Virsual Studio"></a>chapter 3 - Virsual Studio</h1><p>VS使用起来比较笨重，有些配置不对会导致程序执行失败，比如找不到指定文件等，这个错误主要是没有生成.exe文件，可能是编译失败等原因，可以具体问题具体解决。这一块我暂时还没有完全搞清楚，后面用的多了再补。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/17/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h1><h3 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h3><p>Miller-Rabin测试、快速幂、扩展欧几里得算法、欧拉函数、欧拉公式、同余式、乘法逆元、密钥、公钥、私钥</p><blockquote><p>为了方便理解，这里先简单介绍上述知识的意义：<br><strong>Miller-Rabin测试</strong>：用于测试一个数是否为质数；单次测试存在小概率误判可能，即让一个非质数通过测试；可以使用不同参数做多次独立测试，让误判概率小到忽略不计；<br><strong>快速幂</strong>：把幂次用二进制形式表示来计算，可以在$O(log_2 N)$复杂度完成幂运算；<br><strong>扩展欧几里得算法</strong>：用于求解二元一次方程，得到一组解；<br><strong>欧拉函数</strong>：$\phi(n)$，表示小于 n 的正整数中，与 n 互质的数的个数(最大公因数为 1 的数的个数)。显然，如果 n 为质数，则$\phi(n)&#x3D;n-1$;可以证明：若有<strong>两个质数P、Q</strong>，且$P\times Q&#x3D;n$，则：</p><p>$$<br>\phi(n)&#x3D;\phi(P\times Q)&#x3D;\phi(P)\times\phi(Q)&#x3D;(P-1)\times (Q-1)<br>$$</p><p><strong>欧拉公式</strong>：若 $\alpha$ 与 n 互质，则左式与 1 关于n同余，即：</p><p>$$<br>\alpha^{\phi(n)}\equiv 1 \ (mod\ n)<br>$$</p><p><strong>同余式</strong>：二元运算符 “$\equiv$”，表示左右操作数关于指定的模同余；”$\equiv$”具有 <em><strong>传递性</strong></em> 、可加性、<em><strong>可乘性</strong></em>；即，若 a 与 b 关于 m 同余，c 与 d 关于 m 同余，则：</p><p>$$<br>a+c\equiv b+d<br>$$</p><p>$$<br>a\times c \equiv b\times d<br>$$</p><p><strong>乘法逆元</strong>：若 $a \times b \equiv 1(modm)$，则 a 与 b 互相称为彼此关于 m 的乘法逆元；<br><strong>密钥</strong>：用于对称加密方式，表示明文和密文的转换规则；在对称加密方式下，转换使用的是同一套规则，一旦规则被第三方获知，就会存在泄密风险<br><strong>公钥</strong>：用于非对称加密方式，表示加密的规则，公钥被第三方获知不存在安全风险；<br><strong>私钥</strong>：用于非对称加密方式，表示解密规则，私钥的保管非常重要，一旦泄露就有泄密风险。<br><strong>补充说明</strong>：关于可逆加密和<strong>不可逆加密</strong>：对称和非对称都是可逆的，即可以根据某种规则从密文解出明文；不可逆加密是指，明文转化为密文由系统执行，一旦转化为密文，则不可能在合理时间内解出明文。这种加密方式一般用于口令加密，只有重新输入明文，并再次经过同样不可逆的加密算法处理，得到相同的加密密文并被系统重新识别后，才能真正解密。</p></blockquote><p><strong>快速幂计算方法</strong>：<br><img src="/medias/images/01.jpg" alt="快速幂" title="快速幂"></p><h3 id="2-算法背景"><a href="#2-算法背景" class="headerlink" title="2. 算法背景"></a>2. 算法背景</h3><p>&amp;emsp;网络上流传着这样一句话，RSA算法是地球上最重要的算法，没有之一。因为如果没有RSA算法，现在的网络世界就毫无安全可言，所有数据都是可通过技术手段被窃取的，也就不会产生信任和交易。<br>&amp;emsp;想要理解RSA算法的重要性，就要先解释<strong>对称加密算法</strong>和<strong>非对称加密算法</strong>的概念。<br>&amp;emsp;在1976年以前，所有加密方法都使用<strong>对称加密算法</strong>：加密和解密使用同一套规则。例如：甲使用密钥 A 加密，将密文传递给乙，乙仍使用密钥 A 解密。如果密钥 A 在甲传递给乙的过程中泄露，或者根据已知的密文和明文的对应规律推导出密钥 A，则甲乙之间的通讯将毫无秘密可言。<br>&amp;emsp;1976年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不传递密钥的情况下，完成解密。这被称为<strong>Diffie-Hellman密钥交换算法</strong>。假如甲要和乙通讯，甲使用公钥 A 加密，将密文传递给乙，乙使用私钥 B 解密得到明文。其中<strong>公钥在网络上传递，私钥只有乙自己拥有</strong>，不在网络上传递。这样即使知道了公钥 A 也无法解密，反过来通讯也一样。只要私钥不泄漏，通信就是安全的，这就是<strong>非对称加密算法</strong>。<br>&amp;emsp;1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。</p><h3 id="3-RSA的原理"><a href="#3-RSA的原理" class="headerlink" title="3. RSA的原理"></a>3. RSA的原理</h3><h4 id="I-RSA公钥"><a href="#I-RSA公钥" class="headerlink" title="I. RSA公钥"></a>I. RSA公钥</h4><blockquote><p>RSA公钥可表示为 **(n,e)**，其中，$n&#x3D;P \times Q$，P、Q均为质数，且P、Q越大越安全。实际使用中，n的二进制位数要达到1024位，对于特别重要的场合，要达到2048位。e 是一个随机生成的质数，要求 e 满足：<br>$1&lt;e&lt;\phi(n)$，且 e 与 $\phi(n)$ 互质。</p></blockquote><h4 id="II-RSA私钥"><a href="#II-RSA私钥" class="headerlink" title="II. RSA私钥"></a>II. RSA私钥</h4><blockquote><p>RSA私钥可以表示为 **(n,d)**，其中，d 是由扩展欧几里得法求解二元一次方程得出的一个解（一组解中的任意一个）。该二元一次方程由以下规则产生：<br>$(e\times d)\ %\ \phi(n) &#x3D; 1$，即 $(e\times d)-1 &#x3D; y\times \phi(n)$</p></blockquote><h4 id="III-加解密过程"><a href="#III-加解密过程" class="headerlink" title="III. 加解密过程"></a>III. 加解密过程</h4><blockquote><p>加密：<br>$$(明文)^e\ %\ n &#x3D; (密文)$$</p></blockquote><blockquote><p>解密：<br>$$(密文)^d\ %\ n &#x3D; (明文)$$</p></blockquote><h4 id="IV-为什么安全？"><a href="#IV-为什么安全？" class="headerlink" title="IV. 为什么安全？"></a>IV. 为什么安全？</h4><p>&amp;emsp;RSA算法允许公钥 (n,e) 被获知，我们假设最糟糕的情况：n、e 和密文均已被第三方获知，此时他仍然不知道 P、Q 和 d。如果他想要破译，由加密规则可知，无法直接逆运算。而如果想得到 d，则需要先知道 $\phi(n)$，求 $\phi(n)$ 需要知道 P 和 Q（这也是为什么 <strong>RSA算法需要n取一个非常大的数的原因</strong>，否则不用知道 P 和 Q 就可以直接暴力解$\phi(n)$）。然而，对超大整数做因数分解是数学界公认的一个难题，这个难度决定了 RSA 的可靠性。如果依靠暴力法解 P、Q 或者 $ \phi(n) $，这个时间复杂度为指数级，按现有最大运算速度，要算很多年才能破解，因此 RSA 是安全的。</p><h3 id="4-RSA的过程"><a href="#4-RSA的过程" class="headerlink" title="4. RSA的过程"></a>4. RSA的过程</h3><blockquote><p>I. &amp;thinsp;&amp;thinsp;本地用MR测试生成超大的 P、Q，并以此求出 n。<br>II. &amp;thinsp;本地按规则随机生成 e。<br>III. 利用扩展欧几里得法，本地求 e 关于 $\phi(n)$ 的乘法逆元 d。即：<br>$$e\times d \equiv 1\ (mod\ \phi(n))$$</p></blockquote><p>&amp;emsp;此时公钥和私钥均已构建完毕，但为什么就可以加密和解密呢？我们举个例子来看看。</p><blockquote><p>设某明文 $\alpha$ 与 n 互质，由欧拉公式：<br>$$\alpha^{\phi(n)}\equiv 1\ (mod\ n)$$<br>由可乘性：<br>$$\alpha^{k\phi(n)+1}\equiv \alpha\ (mod\ n)$$<br>由 d 的定义，也就是说：<br>$$\alpha^{ed}\equiv \alpha\ (mod\ n)$$<br>由加密法则 $\alpha^e\ %\ n &#x3D; C$ 可知，密文 C 满足：<br>$$C\equiv \alpha^e\ (mod\ n)$$<br>则：<br>$$C^d\equiv \alpha^{ed}\equiv\alpha\ (mod\ n)$$<br>因此：<br>$$C^d\ %\ n &#x3D; \alpha$$</p></blockquote><h3 id="5-补充说明"><a href="#5-补充说明" class="headerlink" title="5. 补充说明"></a>5. 补充说明</h3><p>&amp;emsp;RSA一般作为外层加密算法，为对称加密算法的密钥做加密；此外，由于P、Q实际取值时相差不会太大，RSA的可破解性还有待商榷。<br><strong>为什么要求e与$\phi(n)$互斥？</strong> 因为只有这样才能保证e的逆（私钥）唯一存在。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/markdown%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/17/markdown%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><ol><li><p>标题：</p><blockquote><p>&amp;emsp;法一：#<br>&amp;emsp;法二：—- 或 &#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote></li><li><p>空格space entity：</p><blockquote><p>&amp;emsp;&amp;emsp：全角; 或 &amp;ensp：半角; 或 &amp;thinsp：$\frac{1}{6}$空格;</p></blockquote></li><li><p>引用框</p><blockquote><p>&amp;emsp;’&gt;’&amp;emsp;&amp;emsp;&#x2F;&#x2F;注：跳出打一个回车即可<br>&amp;emsp;引用的嵌套层数由’&gt;’的数目决定；需要返回到上一节时，加一个以相应引用符开启的空行即可；</p></blockquote></li><li><p>有序列表</p><blockquote><p>&amp;emsp; 数字 + 点 + 空格；eg, ‘1. ‘</p></blockquote></li><li><p>转义符</p><blockquote><p>&amp;emsp; ‘ \ &#39;</p></blockquote></li><li><p>数学表达式</p><blockquote><p>&amp;emsp;I.&amp;ensp;文字内表达式：$表达式内容$<br>&amp;emsp;II.&amp;thinsp;&amp;thinsp;另起一行居中表达式：$$表达式内容$$<br>&amp;emsp;III.上标用’^’、下标用’_’<br>&amp;emsp;IV.乘号：$\times $、 除号：$\div $<br>&amp;emsp;V. 其他用法参考：<a href="https://blog.csdn.net/jyfu2_12/article/details/79207643?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167645466016800192223743%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167645466016800192223743&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79207643-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev1%5Einsert_chatgpt&utm_term=markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F&spm=1018.2226.3001.4187" title="CSDN">markdown数学公式速查</a></p></blockquote></li><li><p>图片</p><blockquote><p>![anchor text](img_src “title”)<br>anchor text 用于源码模式和图片未成功加载提示图片用途<br>img_src 是图片地址，可以是本地的也可以是网络图床<br>title 是图片标题，默认是鼠标悬浮显示</p></blockquote></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
