<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/02/17/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/17/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Machine-Learning-amp-Deep-Learning"><a href="#Machine-Learning-amp-Deep-Learning" class="headerlink" title="Machine Learning &amp; Deep Learning"></a>Machine Learning &amp; Deep Learning</h1><hr><h2 id="chapter-1-基础知识"><a href="#chapter-1-基础知识" class="headerlink" title="chapter 1. 基础知识"></a>chapter 1. 基础知识</h2><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p><strong>Machine Learning ≈ Looking for a Correct Function</strong><br>eg.语音识别：f(语音信号) &#x3D; “How are you”<br>&amp;emsp;&amp;ensp;图像识别：f(图片) &#x3D; “cat”<br>&amp;emsp;&amp;ensp;alpha Go：f(棋盘) &#x3D; “下一步落子位置”<br><strong>f的正常编写会很困难，而机器学习就是帮我们找出：人写不出来的那个”复杂函数f”</strong></p><h3 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h3><p>要找的那个函数f是一个 <strong>“类神经网络”</strong></p><h3 id="机器学习的输入与输出"><a href="#机器学习的输入与输出" class="headerlink" title="机器学习的输入与输出"></a>机器学习的输入与输出</h3><p><strong>机器学习可以分为两大类任务，一类叫做regression，另一类叫做classificaton</strong><br>输入可以是一个vector、一个matrix（图片识别）或是一个sequence（语音辨识、翻译）<br>输出可以是一个数值scalar、一组类别或是更复杂的输出，如一篇文章等<br>输出是数值scalar的称为regression，即回归；例如数值预测；<br>输出是类别的，即为机器提供几个选项让他选择，称为分类classification；例如垃圾邮件识别，alpha-Go(所有落点选一个);</p><h3 id="机器如何自动的找出这个函数F"><a href="#机器如何自动的找出这个函数F" class="headerlink" title="机器如何自动的找出这个函数F"></a>机器如何自动的找出这个函数F</h3><p>Supervised Learning监督学习：在Training Data中设置label;缺点是要收集大量数据和设置标签，在实际中难以做到；<br>Self-supervised Learning自监督学习：在训练之前“先练成一些基本功”，即Pre-train预训练 + Downstream Tasks下游任务；<br>Pre-train和Downstream Tasks的关系就好像开发OS和开发APP的关系;<br>Pre-tarined Model也叫Foundation Model，其中最有名的就是BERT模型，有340个参数parameters（《芝麻街》中的小黄人）；此外还有：GPT-3、GPT-2、T5、ELMo；</p><h3 id="补充介绍"><a href="#补充介绍" class="headerlink" title="补充介绍"></a>补充介绍</h3><p><strong>generative adversarial network</strong>：将unpaired的数据输入让机器自己学习得出结果的一种技术；目前做的最好的是facebook的一篇论文：</p><blockquote><p><a href="https://arxiv.org/abs/2105.11084">https://arxiv.org/abs/2105.11084</a></p></blockquote><p><strong>reinforcement learning</strong>：强化学习，适用于难以打标签的场合；例如围棋，人很难知道下一步应该落在哪里是最好的，但我们可以告诉机器什么是好的结果，什么是不好的结果；<br><strong>anomaly detection</strong>：异常检测，让机器拥有回答”我不知道”的能力；<br><strong>explainable AI</strong>：可解释性AI，让机器不仅能输出结果，还要告诉我们为什么，以具有更好的可解释性；<br><strong>model attack</strong>:人类对训练模型的攻击；如插入杂讯；<br><strong>domain adaptation</strong>：域适应；针对实际接受的场景可能与训练场景有区别的情况；比如训练用的是黑白图片，实际变成彩色图片；<br><strong>network compression</strong>：模型压缩，从而让他们跑在更简单的设备上；例如手机、手表；<br><strong>life-long learning</strong>：让机器不断学习新技术会有什么困难？<br><strong>meta learning</strong>：meta learning &#x3D; learn to learn，即让机器学会学习；meta learning往往用于实现<strong>Few-shot learning</strong>，即采用非常少量的资料让机器学会目标；</p><h3 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h3><p>python、google colab<br>colab全称为Colaboratory,是免费的Jupyter运行环境,并且完全在云端运行。最重要的是免费，而且不需要你自己去装深度学习的环境</p><h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><p><a href="https://www.kaggle.com/">https://www.kaggle.com</a><br>一个机器学习的线上平台，包含了很多竞赛内容，部分竞赛甚至设有奖金；<br>项目做完后可以上传到kaggle上跑分，并获知排行；<br>public leaderboard在上传后就可以看到；包含一部分测试集；<br>private leaderboard要在deadline后；包含另一部分；</p><hr><h2 id="chapter-2-Regression"><a href="#chapter-2-Regression" class="headerlink" title="chapter 2. Regression"></a>chapter 2. Regression</h2><h3 id="什么是regression"><a href="#什么是regression" class="headerlink" title="什么是regression"></a>什么是regression</h3><p>the function outputs a scalar<br>例如，输入今天的气象参数到函数f，得出未来的pm2.5的值；</p><h3 id="Structured-Learning"><a href="#Structured-Learning" class="headerlink" title="Structured Learning"></a>Structured Learning</h3><p>即create something with structure(image、document)；用拟人化的方式来说，就是不只是让机器得出结果，还要让机器会创造。</p><h3 id="机器如何找出函数F（即训练过程）"><a href="#机器如何找出函数F（即训练过程）" class="headerlink" title="机器如何找出函数F（即训练过程）"></a>机器如何找出函数F（即训练过程）</h3><blockquote><p>“三步走”：</p><ol><li>写出一个带有未知参数的函数，即猜测一下我们需要预测的目标的数学关系式是什么样的。（eg.猜测明日油管播放量 y &#x3D; b + wx，x是今日播放量，b 和 w 是未知数，w 可以表示权重 weight，b 可以表示 bias）这个带有未知参数的函数也称为<strong>模型</strong>。</li><li>定义Loss：Loss也是一个Function，此function的输入是model的参数（eg.对于上面的举例，Loss可以表示为L(b,w)）。Loss这个Function输出的值的意义是衡量当前参数的取值好还是不好。一般的，Loss越小，说明取的参数越好。<br><strong>Loss的计算方式</strong>：MAE(mean absolute error)、MSE(mean square error)等；<br>注意：Loss是可以根据实际场景去自己定义的。</li><li>Optimization最佳化；即找出最好的 $w^{<em>}$ 和 $b^{</em>}$，使得Loss取最小值。<br>一个最常用的optimize的方法就是Gradient Descent，即<strong>梯度下降法</strong>。<br><strong>梯度下降法的步骤</strong>：<br>I. 先随机取一个点$w_0$；<br>II. 然后计算 $\frac{\partial L}{\partial w}|<em>{w&#x3D;w_0}$ ，如果为负，则增加w；如果为正，则减小w；<br>每次移动的值表示为 $\eta\frac{\partial L}{\partial w}|</em>{w&#x3D;w_0}$ ；即偏微分越大，移动越多；$\eta$ 称为<strong>learning rate</strong>，即学习率，$\eta$ 越大每次跳的越多，反之越小。它的值是由我们自己去定义的。像 $\eta$ 这样由我们设定而非机器去学习得来的参数称为 <strong>hyperparameter</strong>；<br>III. 接下来更新 w，即 $w_1&#x3D;w_0-\eta\frac{\partial L}{\partial w}|_{w&#x3D;w_0}$<br><strong>思考：为什么是减？</strong> 原因是我们希望找最小的L，当偏导为负时要增加，偏导为正时要减小；联系梯度下降的概念，实际上梯度是当前函数增加最快的方向，则 <strong>负梯度方向是函数减少最快的方向。</strong><br>IV. 持续移动 w 直到结束；<strong>结束条件</strong>可以是更新次数上限(hyperparameter)、微分值为零的点(<strong>局部最优解local minima</strong>)；</li></ol></blockquote><h3 id="关于方向导数和梯度的数学补充"><a href="#关于方向导数和梯度的数学补充" class="headerlink" title="关于方向导数和梯度的数学补充"></a>关于方向导数和梯度的数学补充</h3><p>关于方向导数：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/方向导数.PNG" alt="方向导数" title="方向导数"><br>关于梯度：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/梯度.PNG" alt="梯度" title="梯度"><br>多参数问题用Gradient Decent:<br><img src="D:/Desktop/我的文件/笔记/图片笔记/gradient_decent.png" alt="Gradient Decent" title="Gradient Decent"><br>实例：<br><img src="D:/Desktop/我的文件/笔记/图片笔记/梯度下降实例.png" alt="实例" title="Gradient 梯度下降"></p><h3 id="模型修改"><a href="#模型修改" class="headerlink" title="模型修改"></a>模型修改</h3><p><strong>对模型的修改往往源于对于问题实际情况的深入理解，即Domain Knowledge</strong><br>一般来讲，在训练数据上考虑因素越多，在训练集上的Loss越小。例如，预测播放量中考虑前一天和考虑前七天的差异。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%80%81%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%80%81%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Missing-Semester"><a href="#Missing-Semester" class="headerlink" title="Missing Semester"></a>Missing Semester</h1><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>&amp;emsp;在麻省理工，有一门课程叫做missing semester，讲授如何高效的使用计算机工具。我想引用课程介绍中的一段话：“计算机是为自动化手工任务而生的，然而学生们却经常用手来完成重复性的任务。计算机生态系统知识，没有作为作为大学课程的一部分来教授。学生们从来没有被告知如何使用这些工具，或者至少没有被告知如何有效的使用这些工具，从而将精力和时间浪费在了本应简单的任务上”。趁着这段时间可以自由安排，我实践和学习了很多基础性的知识，算是补上自己缺失的一课。我将所学记录下来，于是便有了这篇博客。</p><h1 id="chapter-1-compiler"><a href="#chapter-1-compiler" class="headerlink" title="chapter 1 - compiler"></a>chapter 1 - compiler</h1><h3 id="GNU、gcc和MinGW"><a href="#GNU、gcc和MinGW" class="headerlink" title="GNU、gcc和MinGW"></a>GNU、gcc和MinGW</h3><p>首先了解GPL和GNU Project：<br><strong>GNU Project</strong>：革奴计划，是一个自由软件集体协作计划，1983年9月27日由理查德·斯托曼在麻省理工学院公开发起。它的目的是创建一套完全自由的操作系统，这个操作系统称为GNU。</p><blockquote><p>&gt;小故事:<br>&amp;emsp;相关的所有缩写的“G”均来自Gnu的首字母。gnu本来的意思是牛羚，也叫角马。GNU的吉祥物也正是角马。至于为什么选”Gnu”，斯托曼博士说当时他觉得好玩，他小时候听过一首歌，很喜欢，歌名是《The Gnu》</p></blockquote><p><strong>GPL</strong>：即GNU通用公共许可协议(GNU General Public License)，也叫GNU GPL，它有两个特点：</p><ol><li>一方面，它给予用户充分的自由，允许用户自由的运行、学习、共享和修改软件；</li><li>另一方面，它有一个严格的限制——GPL的派生作品也必须以GPL的许可形式发放；</li></ol><p>&amp;emsp;通俗的说就是：软件随便用，源码也给你，随你怎么copy怎么修改，这都是你的自由，但是！你不能将大伙的劳动成果变成你一个人私有的！</p><blockquote><p>&gt;小故事:<br>&amp;emsp;从某种程度上说，GPL和GNU计划其实都源于当时兴起的软件著作权“copyright”。copyright的存在，让理查德等人在实际使用中感到诸多不便，为了打破这种限制和“不自由”，他发起了GNU计划，并撰写了许可协议GPL，让他所倡导的自由精神传续下去。不得不说，这种initiative spirit实在值得我们去学习。</p></blockquote><p>接下来介绍GNU和Linux：<br><strong>GNU</strong>：GNU的全称是GNU’s NOT UNIX，它本质上是一个自由的操作系统，其内容软件完全以GPL方式发布。我们现在提到GNU，一般是指这个操作系统，而不是GNU Project。</p><blockquote><p>&gt;补充资料<br>&amp;emsp;众所周知，开发操作系统是非常困难的一件事。UNIX作为一个非常强大且成熟的商用操作系统，虽然理查德不喜欢它的商业限制，但迫于UNIX的强大生态，GNU依然不得不去实现UNIX的标准接口。直到1990年，GNU计划已经开发出的软件包括一个功能强大的文字编辑器Emacs、C语言编译器GCC以及大部分UNIX系统的程序库和工具。但最重要的操作系统内核部分依然没有完成。此时，另一个天才Linux出现了。</p></blockquote><p><strong>Linux</strong>：Linux系统于1991年发布，据说他的作者，时年21岁的Linux开发这个系统的本意只是为了更好的下载学校资源。虽然Linux本人当时开发出来的只有<strong>Linux内核</strong>（即<strong>只具备与硬件打交道的能力</strong>，其他人性化的功能全都没有，比如GUI等）但由于Linux与Unix兼容且在GPL下发布，所以Linux在网络上流传非常快。后来，经过全世界程序员的积极贡献，基于当初的Linux内核，已经有了诸如 <strong>Ubuntu</strong> 这样的优秀发行版本。</p><p>现在我们已经知道了GNU project、GPL、以及GNU和Linux的渊源，那么，实际开发中我们常用到的gcc、g++、MinGW又是什么东西呢？<br><strong>gcc</strong>：全称为GNU Compiler Collection，是GNU编译器套装。需要注意的是，<strong>gcc是一个完整的套件</strong>，包含编译前端、汇编器、归档器、连接器，以及所支持的各个语言的库等。gcc原本叫做GNU C Compiler，因为最初只能编译C语言。此后gcc迅速得到扩展，开始支持C++，再后来已经可以处理Pascal、Objective-C、JAVA、Go等多种语言。由于gcc的巨大影响力(<strong>特别是其中的C语言编译器</strong>)，它常被认为是跨平台编译器的事实标准。在很多操作系统，包括很多“类UNIX系统”中，都将gcc作为标准编译器。</p><p>**g++**：g++是gcc的c++编译器</p><p><strong>MinGW</strong>：MinGW全称是Minimalist GNU for Windows。顾名思义，MinGW实质上是GNU在windows系统的一个移植版本。所谓minimalist，就是指<strong>这个移植版本只包含针对C&#x2F;C++的编译器工具集</strong>。此外，类似的移植版本还有cygwin和Djgpp，这里不做介绍。</p><h1 id="chapter-2-VScode"><a href="#chapter-2-VScode" class="headerlink" title="chapter 2 - VScode"></a>chapter 2 - VScode</h1><ol><li>下载和安装：官网免费下载，安装时选择添加到path；</li><li>汉化：安装后在VSCode扩展中安装Chinese插件</li><li>C&#x2F;C++相关部分：<blockquote><p>I. VSCode扩展安装C&#x2F;C++插件和code runner插件；后者需要设置ignore selection 和  run in terminal<br>II. 本机安装和配置MinGW:</p><blockquote><p>下载时，官网选择x86_64-posix-seh，本地解压即可；解压时我使用的软件是7-zip;<br>在系统变量的path中添加mingw主目录中的bin和include；<br>cmd测试安装配置结果：gcc -v -E -x c++ -</p></blockquote><p>III. 在VSCode的工程项目中新建一个.vscode文件(后续代码源文件也放在此.vscode文件中)，然后在此文件中添加三个配置文件：c_cpp_propertise.json、launch.json、tasks.json。注意修改其中的路径为本机安装的mingw的gcc或g++下设的相应文件，gcc针对C项目，g++针对C++项目。（配置文件的具体内容保存在本地了，这里不展开）<br>IV.注意事项：win的路径复制下来是\，会被当作转义符处理，在VSCode中配置路径时要改为\或者&#x2F;，这一点是VSCode配置中常见的错误。</p></blockquote></li><li>运行&#x2F;调试：右上角Run Code&#x2F;其他相应选项</li><li>关于VScode的json文件中无法添加注释的问题：<blockquote><p>在JSON中，使用以下两种方式来表示数据：<br>I. Object（对象）：键值对的集合，使用花括号{ }定义。在每个键值对中，以键开头，后跟一个冒号，最后是值。多个键值对之间使用逗号,分隔，例如{“name”:”blog”,”url”:”xx.xx.xx”}；<br>II. Array（数组）：值的有序集合，使用方括号[ ]定义，数组中每个值之间使用逗号进行分隔。<br>VSCode中如果想在json文件加注释，可以将底部蓝色状态栏中的语言模式设置为Json with Comments；</p></blockquote></li><li>字体间距变大问题解决：terminal.integrated.fontFamily设置为monospace</li><li>VSCode实用插件<blockquote><p><strong>markdown preview enhanced</strong>：编写markdown，上方状态栏打开侧边预览即可边写边预览<br><strong>partial diff</strong>：查看代码差异，选中一段后右键select text for cmp，再选中另一段cmp with previous<br><strong>markmap</strong>：绘制思维导图；类似markdown的语法，用’#’控制即可；上方状态栏open as markmap查看效果；</p></blockquote></li></ol><h1 id="chapter-3-Virsual-Studio"><a href="#chapter-3-Virsual-Studio" class="headerlink" title="chapter 3 - Virsual Studio"></a>chapter 3 - Virsual Studio</h1><p>VS使用起来比较笨重，有些配置不对会导致程序执行失败，比如找不到指定文件等，这个错误主要是没有生成.exe文件，可能是编译失败等原因，可以具体问题具体解决。这一块我暂时还没有完全搞清楚，后面用的多了再补。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/17/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h1><h3 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h3><p>Miller-Rabin测试、快速幂、扩展欧几里得算法、欧拉函数、欧拉公式、同余式、乘法逆元、密钥、公钥、私钥</p><blockquote><p>为了方便理解，这里先简单介绍上述知识的意义：<br><strong>Miller-Rabin测试</strong>：用于测试一个数是否为质数；单次测试存在小概率误判可能，即让一个非质数通过测试；可以使用不同参数做多次独立测试，让误判概率小到忽略不计；<br><strong>快速幂</strong>：把幂次用二进制形式表示来计算，可以在$O(log_2 N)$复杂度完成幂运算；<br><strong>扩展欧几里得算法</strong>：用于求解二元一次方程，得到一组解；<br><strong>欧拉函数</strong>：$\phi(n)$，表示小于 n 的正整数中，与 n 互质的数的个数(最大公因数为 1 的数的个数)。显然，如果 n 为质数，则$\phi(n)&#x3D;n-1$;可以证明：若有<strong>两个质数P、Q</strong>，且$P\times Q&#x3D;n$，则：$$\phi(n)&#x3D;\phi(P\times Q)&#x3D;\phi(P)\times \phi(Q)&#x3D;(P-1)\times (Q-1)$$<br><strong>欧拉公式</strong>：若 $\alpha$ 与 n 互质，则左式与 1 关于n同余，即：$$\alpha^{\phi(n)}\equiv 1 \ (mod\ n)$$<br><strong>同余式</strong>：二元运算符 “$\equiv$”，表示左右操作数关于指定的模同余；”$\equiv$”具有 <em><strong>传递性</strong></em> 、可加性、<em><strong>可乘性</strong></em>；即，若 a 与 b 关于 m 同余，c 与 d 关于 m 同余，则：<br>$$a+c\equiv b+d$$<br>$$a\times c \equiv b\times d$$<br><strong>乘法逆元</strong>：若 $a \times b \equiv 1(modm)$，则 a 与 b 互相称为彼此关于 m 的乘法逆元；<br><strong>密钥</strong>：用于对称加密方式，表示明文和密文的转换规则；在对称加密方式下，转换使用的是同一套规则，一旦规则被第三方获知，就会存在泄密风险<br><strong>公钥</strong>：用于非对称加密方式，表示加密的规则，公钥被第三方获知不存在安全风险；<br><strong>私钥</strong>：用于非对称加密方式，表示解密规则，私钥的保管非常重要，一旦泄露就有泄密风险。<br><strong>补充说明</strong>：关于可逆加密和<strong>不可逆加密</strong>：对称和非对称都是可逆的，即可以根据某种规则从密文解出明文；不可逆加密是指，明文转化为密文由系统执行，一旦转化为密文，则不可能在合理时间内解出明文。这种加密方式一般用于口令加密，只有重新输入明文，并再次经过同样不可逆的加密算法处理，得到相同的加密密文并被系统重新识别后，才能真正解密。</p></blockquote><h3 id="2-算法背景"><a href="#2-算法背景" class="headerlink" title="2. 算法背景"></a>2. 算法背景</h3><p>&amp;emsp;网络上流传着这样一句话，RSA算法是地球上最重要的算法，没有之一。因为如果没有RSA算法，现在的网络世界就毫无安全可言，所有数据都是可通过技术手段被窃取的，也就不会产生信任和交易。<br>&amp;emsp;想要理解RSA算法的重要性，就要先解释<strong>对称加密算法</strong>和<strong>非对称加密算法</strong>的概念。<br>&amp;emsp;在1976年以前，所有加密方法都使用<strong>对称加密算法</strong>：加密和解密使用同一套规则。例如：甲使用密钥 A 加密，将密文传递给乙，乙仍使用密钥 A 解密。如果密钥 A 在甲传递给乙的过程中泄露，或者根据已知的密文和明文的对应规律推导出密钥 A，则甲乙之间的通讯将毫无秘密可言。<br>&amp;emsp;1976年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不传递密钥的情况下，完成解密。这被称为<strong>Diffie-Hellman密钥交换算法</strong>。假如甲要和乙通讯，甲使用公钥 A 加密，将密文传递给乙，乙使用私钥 B 解密得到明文。其中<strong>公钥在网络上传递，私钥只有乙自己拥有</strong>，不在网络上传递。这样即使知道了公钥 A 也无法解密，反过来通讯也一样。只要私钥不泄漏，通信就是安全的，这就是<strong>非对称加密算法</strong>。<br>&amp;emsp;1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。</p><h3 id="3-RSA的原理"><a href="#3-RSA的原理" class="headerlink" title="3. RSA的原理"></a>3. RSA的原理</h3><h4 id="I-RSA公钥"><a href="#I-RSA公钥" class="headerlink" title="I. RSA公钥"></a>I. RSA公钥</h4><blockquote><p>RSA公钥可表示为 **(n,e)**，其中，$n&#x3D;P \times Q$，P、Q均为质数，且P、Q越大越安全。实际使用中，n的二进制位数要达到1024位，对于特别重要的场合，要达到2048位。e 是一个随机生成的质数，要求 e 满足：<br>$1&lt;e&lt;\phi(n)$，且 e 与 $\phi(n)$ 互质。</p></blockquote><h4 id="II-RSA私钥"><a href="#II-RSA私钥" class="headerlink" title="II. RSA私钥"></a>II. RSA私钥</h4><blockquote><p>RSA私钥可以表示为 **(n,d)**，其中，d 是由扩展欧几里得法求解二元一次方程得出的一个解（一组解中的任意一个）。该二元一次方程由以下规则产生：<br>$(e\times d)\ %\ \phi(n) &#x3D; 1$，即 $(e\times d)-1 &#x3D; y\times \phi(n)$</p></blockquote><h4 id="III-加解密过程"><a href="#III-加解密过程" class="headerlink" title="III. 加解密过程"></a>III. 加解密过程</h4><blockquote><p>加密：<br>$$(明文)^e\ %\ n &#x3D; (密文)$$</p></blockquote><blockquote><p>解密：<br>$$(密文)^d\ %\ n &#x3D; (明文)$$</p></blockquote><h4 id="IV-为什么安全？"><a href="#IV-为什么安全？" class="headerlink" title="IV. 为什么安全？"></a>IV. 为什么安全？</h4><p>&amp;emsp;RSA算法允许公钥 (n,e) 被获知，我们假设最糟糕的情况：n、e 和密文均已被第三方获知，此时他仍然不知道 P、Q 和 d。如果他想要破译，由加密规则可知，无法直接逆运算。而如果想得到 d，则需要先知道 $\phi(n)$，求 $\phi(n)$ 需要知道 P 和 Q（这也是为什么 <strong>RSA算法需要n取一个非常大的数的原因</strong>，否则不用知道 P 和 Q 就可以直接暴力解$\phi(n)$）。然而，对超大整数做因数分解是数学界公认的一个难题，这个难度决定了 RSA 的可靠性。如果依靠暴力法解 P、Q 或者 $ \phi(n) $，这个时间复杂度为指数级，按现有最大运算速度，要算很多年才能破解，因此 RSA 是安全的。</p><h3 id="4-RSA的过程"><a href="#4-RSA的过程" class="headerlink" title="4. RSA的过程"></a>4. RSA的过程</h3><blockquote><p>I. &amp;thinsp;&amp;thinsp;本地用MR测试生成超大的 P、Q，并以此求出 n。<br>II. &amp;thinsp;本地按规则随机生成 e。<br>III. 利用扩展欧几里得法，本地求 e 关于 $\phi(n)$ 的乘法逆元 d。即：<br>$$e\times d \equiv 1\ (mod\ \phi(n))$$</p></blockquote><p>&amp;emsp;此时公钥和私钥均已构建完毕，但为什么就可以加密和解密呢？我们举个例子来看看。</p><blockquote><p>设某明文 $\alpha$ 与 n 互质，由欧拉公式：<br>$$\alpha^{\phi(n)}\equiv 1\ (mod\ n)$$<br>由可乘性：<br>$$\alpha^{k\phi(n)+1}\equiv \alpha\ (mod\ n)$$<br>由 d 的定义，也就是说：<br>$$\alpha^{ed}\equiv \alpha\ (mod\ n)$$<br>由加密法则 $\alpha^e\ %\ n &#x3D; C$ 可知，密文 C 满足：<br>$$C\equiv \alpha^e\ (mod\ n)$$<br>则：<br>$$C^d\equiv \alpha^{ed}\equiv\alpha\ (mod\ n)$$<br>因此：<br>$$C^d\ %\ n &#x3D; \alpha$$</p></blockquote><h3 id="5-补充说明"><a href="#5-补充说明" class="headerlink" title="5. 补充说明"></a>5. 补充说明</h3><p>&amp;emsp;RSA一般作为外层加密算法，为对称加密算法的密钥做加密；此外，由于P、Q实际取值时相差不会太大，RSA的可破解性还有待商榷。<br><strong>为什么要求e与$\phi(n)$互斥？</strong> 因为只有这样才能保证e的逆（私钥）唯一存在。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/17/markdown%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/17/markdown%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><ol><li>标题：<blockquote><p>&amp;emsp;法一：#<br>&amp;emsp;法二：—- 或 &#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote></li><li>空格space entity：<blockquote><p>&amp;emsp;&amp;emsp：全角; 或 &amp;ensp：半角; 或 &amp;thinsp：$\frac{1}{6}$空格;</p></blockquote></li><li>引用框<blockquote><p>&amp;emsp;’&gt;’&amp;emsp;&amp;emsp;&#x2F;&#x2F;注：跳出打一个回车即可<br>&amp;emsp;引用的嵌套层数由’&gt;’的数目决定；需要返回到上一节时，加一个以相应引用符开启的空行即可；</p></blockquote></li><li>有序列表<blockquote><p>&amp;emsp; 数字 + 点 + 空格；eg, ‘1. ‘</p></blockquote></li><li>转义符<blockquote><p>&amp;emsp; ‘ \ &#39;</p></blockquote></li><li>数学表达式<blockquote><p>&amp;emsp;I.&amp;ensp;文字内表达式：$表达式内容$<br>&amp;emsp;II.&amp;thinsp;&amp;thinsp;另起一行居中表达式：$$表达式内容$$<br>&amp;emsp;III.上标用’^’、下标用’_’<br>&amp;emsp;IV.乘号：$\times $、 除号：$\div $<br>&amp;emsp;V. 其他用法参考：<a href="https://blog.csdn.net/jyfu2_12/article/details/79207643?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167645466016800192223743%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167645466016800192223743&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79207643-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev1%5Einsert_chatgpt&utm_term=markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F&spm=1018.2226.3001.4187" title="CSDN">markdown数学公式速查</a></p></blockquote></li><li>图片<blockquote><p>![anchor text](img_src “title”)<br>anchor text 用于源码模式和图片未成功加载提示图片用途<br>img_src 是图片地址，可以是本地的也可以是网络图床<br>title 是图片标题，默认是鼠标悬浮显示</p></blockquote></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/17/hello-world/"/>
      <url>/2023/02/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
